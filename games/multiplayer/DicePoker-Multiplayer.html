<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Poker - Multiplayer</title>
    <style>
        :root {
            --bg-dark: #1a1a1a;
            --table-color: #35654d;
            --accent-gold: #ffbd2e;
            --accent-blue: #3498db;
            --accent-red: #e74c3c;
            --accent-green: #27ae60;
            --text-main: #ffffff;
            --text-muted: #aab7b8;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            background: linear-gradient(135deg, var(--bg-dark) 0%, #2d1e1e 100%);
            color: var(--text-main);
            font-family: 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: rgba(0,0,0,0.8);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-gold);
        }

        .brand {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-gold);
        }

        .header-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary { background: var(--accent-gold); color: #000; }
        .btn-primary:hover { background: #ffca57; transform: translateY(-2px); }
        .btn-secondary { background: var(--accent-blue); color: #fff; }
        .btn-secondary:hover { background: #5dade2; }
        .btn-danger { background: var(--accent-red); color: #fff; }
        .btn:disabled { background: #555; cursor: not-allowed; opacity: 0.5; }

        main {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
        }

        .game-area {
            flex: 1;
            background: radial-gradient(circle, var(--table-color) 0%, #1e3b2d 100%);
            border: 20px solid #3e2723;
            border-radius: 20px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .sidebar {
            width: 300px;
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
        }

        .section h3 {
            color: var(--accent-gold);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .player-card {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }

        .player-card.active-turn {
            border-color: var(--accent-gold);
            background: rgba(255,189,46,0.1);
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--accent-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .player-avatar.bot { background: #27ae60; }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .player-score {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .turn-indicator {
            color: var(--accent-gold);
            font-size: 1.5rem;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .dice-container {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .die {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            color: #000;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .die:hover:not(.disabled) { transform: translateY(-5px); }
        .die.held { 
            background: var(--accent-gold); 
            box-shadow: 0 0 20px rgba(255,189,46,0.5);
        }
        .die.disabled { cursor: not-allowed; opacity: 0.5; }

        .game-status {
            font-size: 1.3rem;
            margin: 20px 0;
            color: var(--accent-gold);
            text-align: center;
        }

        .game-info {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            font-size: 1.1rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .info-label {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .info-value {
            color: var(--accent-gold);
            font-size: 1.3rem;
            font-weight: bold;
        }

        .hand-result {
            margin-top: 20px;
            padding: 15px 30px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            font-size: 1.2rem;
            color: var(--accent-gold);
            text-align: center;
            min-height: 50px;
        }

        #toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            border: 2px solid var(--accent-gold);
            font-size: 1rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #toast.show { opacity: 1; }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal.active { display: flex; }

        .modal-content {
            background: #1a1a1a;
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 2rem;
            color: var(--accent-gold);
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }

        .score-row-item {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .score-row-item.winner {
            border-color: var(--accent-gold);
            background: rgba(255,189,46,0.1);
        }

        .winner-badge {
            background: var(--accent-gold);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
        }

        .lobby-code {
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            color: var(--accent-gold);
        }

        .betting-section {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .betting-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .betting-controls button {
            padding: 8px 12px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .betting-controls button:hover {
            background: #5dade2;
            transform: translateY(-2px);
        }

        .bet-display {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .bet-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .bet-label {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .bet-value {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 1.3rem;
        }

        .pot-display {
            background: rgba(255,189,46,0.2);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .pot-value {
            font-size: 2rem;
            color: var(--accent-gold);
            font-weight: bold;
        }

        .player-card.folded {
            opacity: 0.5;
            border-color: var(--accent-red);
        }

        .player-chips {
            font-size: 0.75rem;
            color: var(--accent-gold);
        }

        .btn-success { background: var(--accent-green); color: #fff; }

        .ready-section {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .waiting-on-players {
            font-size: 1rem;
            color: var(--text-muted);
            margin-bottom: 15px;
            min-height: 24px;
        }

        .ready-badge {
            display: inline-block;
            background: #27ae60;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 5px;
        }

        .call-confirmation {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .call-amount {
            font-size: 1.8rem;
            color: var(--accent-gold);
            font-weight: bold;
            margin: 10px 0;
        }

        .spectating-banner {
            background: rgba(52, 152, 219, 0.18);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 12px 20px;
            margin-bottom: 16px;
            text-align: center;
            color: #d6ebff;
            font-weight: bold;
            width: 100%;
            max-width: 640px;
        }

        .spectating-banner .subtext {
            display: block;
            margin-top: 4px;
            font-size: 0.9rem;
            color: var(--text-muted);
            font-weight: normal;
        }
    </style>
</head>
<body>
    <header>
        <div class="brand">üé≤ Dice Poker - Multiplayer</div>
        <div class="header-right">
            <div class="lobby-code">Lobby: <span id="lobby-code-display">...</span></div>
            <button class="btn btn-danger" onclick="returnToLobby()">Leave Game</button>
        </div>
    </header>

    <main>
        <div class="game-area">
            <div class="game-status" id="game-status">Waiting for game to start...</div>
            <div id="spectating-banner" class="spectating-banner" style="display: none;"></div>
            
            <!-- Ready-Up Section -->
            <div id="ready-section" class="ready-section" style="display: none;">
                <div style="font-size: 1.1rem; margin-bottom: 15px; font-weight: bold; color: var(--accent-gold);">Ready to Play?</div>
                <div class="waiting-on-players" id="waiting-on-display"></div>
                <button id="ready-btn" class="btn btn-primary" onclick="markPlayerReady()" style="margin-top: 10px; padding: 12px 30px; font-size: 1.1rem;">
                    ‚úì Ready
                </button>
            </div>
            
            <!-- Pot Display -->
            <div id="pot-display" class="pot-display" style="display: none;">
                <div class="bet-label">POT</div>
                <div class="pot-value" id="pot-value">0</div>
            </div>

            <!-- Betting Section -->
            <div id="betting-section" class="betting-section" style="display: none;">
                <div class="bet-display">
                    <div class="bet-item">
                        <div class="bet-label">Your Chips</div>
                        <div class="bet-value" id="player-chips">1000</div>
                    </div>
                    <div class="bet-item">
                        <div class="bet-label">Current Bet</div>
                        <div class="bet-value" id="bet-display">50</div>
                    </div>
                </div>
                <div id="betting-controls" class="betting-controls" style="display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap;">
                    <button onclick="adjustBet(10)">+10</button>
                    <button onclick="adjustBet(50)">+50</button>
                    <button onclick="adjustBet(100)">+100</button>
                    <button onclick="adjustBet(-10)">-10</button>
                    <button onclick="adjustBet(-50)">-50</button>
                    <button onclick="resetBet()">Reset</button>
                </div>
                <div id="call-confirmation" class="call-confirmation" style="display: none;">
                    <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 10px;">Call amount:</div>
                    <div class="call-amount" id="call-amount-display">0</div>
                    <div id="min-raise-display" style="font-size: 0.9rem; color: var(--text-muted); margin-top: 8px;"></div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button id="place-bet-btn" class="btn btn-primary" onclick="placeBet()" style="width: 150px;">
                        üí∞ Call
                    </button>
                    <button id="raise-btn" class="btn btn-secondary" onclick="raiseBet()" style="width: 150px;">
                        üìà Raise
                    </button>
                    <button id="all-in-btn" class="btn btn-success" onclick="goAllIn()" style="width: 150px;">
                        üî• All In!
                    </button>
                    <button id="fold-btn" class="btn btn-danger" onclick="fold()" style="width: 150px;">
                        ‚ùå Fold
                    </button>
                </div>
            </div>
            
            <div class="dice-container" id="dice-container">
                <!-- Dice will be generated here -->
            </div>

            <div class="hand-result" id="hand-result">Place your bet to start!</div>

            <div style="display: flex; gap: 15px; margin-top: 30px;">
                <button id="roll-btn" class="btn btn-primary" onclick="rollDice()" disabled>
                    üé≤ Roll Dice
                </button>
                <button id="end-turn-btn" class="btn btn-secondary" onclick="endTurn()" disabled>
                    ‚úì End Turn
                </button>
            </div>

            <div class="game-info">
                <div class="info-item">
                    <div class="info-label">Rolls Left</div>
                    <div class="info-value" id="rolls-left">2</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Current Score</div>
                    <div class="info-value" id="current-score">0</div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="section">
                <h3>Players</h3>
                <div id="player-list-container">
                    <!-- Players will be rendered here -->
                </div>
            </div>

            <div class="section">
                <h3>Game Rules</h3>
                <p style="color: var(--text-muted); font-size: 0.9rem; line-height: 1.5;">
                    <strong>Poker Hands (High to Low):</strong><br>
                    Five of a Kind<br>
                    Four of a Kind<br>
                    Full House<br>
                    Straight<br>
                    Three of a Kind<br>
                    Two Pair<br>
                    One Pair<br><br>
                    <strong>How to Play:</strong><br>
                    1. First player sets the bet<br>
                    2. Other players can call, raise, go all-in, or fold<br>
                    3. Each player rolls twice (hold dice)<br>
                    4. Highest hand wins the pot!
                </p>
            </div>
        </div>
    </main>

    <!-- Scoreboard Modal -->
    <div id="scoreboardModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üèÜ Game Over!</div>
            <div id="scoreboardResults"></div>
            <div id="scoreboard-ready-status" style="margin: 12px 0; font-weight: bold; color: var(--accent-gold);"></div>
            <div class="modal-actions">
                <button id="scoreboard-ready-btn" class="btn btn-primary" onclick="markNextRoundReady()">Ready Up</button>
                <button class="btn btn-secondary" onclick="returnToLobbyFromScoreboard()">Return to Lobby</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast"></div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

    <!-- Firebase Config -->
    <script src="../../js/firebaseConfig.js"></script>

    <script>
        // ==============================
        // FIREBASE & LOBBY STATE
        // ==============================
        // Note: db, auth, playerUUID are already declared in firebaseConfig.js
        let lobbyId = null;
        let lobbyRef = null;
        let lobbyPlayers = {};
        let currentMatchState = null;
        let scoreboardShown = false;
        let gameStarted = false;
        let hasFolded = false;
        const GAME_TYPE = 'dicepoker';
        
        // ==============================
        // BETTING & CHIPS
        // ==============================
        const STARTING_CHIPS = 1000;
        const BANKRUPT_SIT_OUT_ROUNDS = 3;
        let playerChips = {};
        let currentBet = 50;
        let currentPot = 0;
        let firstPlayerBet = 50;
        let lastRaiseSize = 50;
        let pendingRaiseTarget = 50;

        // ==============================
        // GAME STATE
        // ==============================
        let dice = [1, 2, 3, 4, 5];
        let heldDice = [false, false, false, false, false];
        let rollsLeft = 2;
        let currentScore = 0;
        let currentLobbyKey = null;
        let gameInitialized = false;
        let bettingStarted = false;
        let bettingStarter = null;
        let isBettingCheckInProgress = false;
        let isRollingCheckInProgress = false;
        let isReadyCheckInProgress = false;
        let isNextRoundCheckInProgress = false;
        let playerTurnComplete = false; // Track if current player completed their turn
        let spectatorView = null;
        let lastAppliedSpectatorUpdatedAt = 0;
        let preparedRollingTurnId = null;
        let botActionTimeout = null;
        let botActionKey = null;
        let botActionInProgressKey = null;

        const BOT_BET_DELAY_MS = 1700;
        const BOT_TURN_START_DELAY_MS = 900;
        const BOT_ROLL_STEP_DELAY_MS = 1200;
        const BOT_TURN_END_DELAY_MS = 700;

        // ==============================
        // INITIALIZATION
        // ==============================
        window.addEventListener('load', async () => {
            // Ensure Firebase is initialized and playerUUID is ready
            const initialized = await ensureFirebaseInitialized();
            if (!playerUUID) {
                console.error('Failed to initialize playerUUID');
                showToast('Error initializing player');
                return;
            }
            
            console.log('playerUUID ready:', playerUUID);
            const hasLobby = await joinLobbyFromURL();
            if (!hasLobby) return; // Stop initialization if no lobby found
            setupRealtimeSync();
            renderDice();
        });

        function initializeFirebase() {
            if (typeof firebase === 'undefined') {
                console.error('Firebase not loaded!');
                return;
            }
            // Firebase should already be initialized by firebaseConfig.js
            // Just ensure db and auth are available
            if (!db) db = firebase.database();
            if (!auth) auth = firebase.auth();
            console.log('Firebase verified');
        }

        async function initializeAuth() {
            return new Promise((resolve) => {
                auth.onAuthStateChanged(async (user) => {
                    if (!user) {
                        try {
                            await auth.signInAnonymously();
                        } catch (error) {
                            console.error('Auth failed:', error);
                        }
                    }
                    
                    // Ensure playerUUID is set from sessionStorage or generate a new one
                    if (!playerUUID) {
                        playerUUID = sessionStorage.getItem('playerUUID');
                        if (!playerUUID) {
                            playerUUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                                const r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
                                return v.toString(16);
                            });
                            sessionStorage.setItem('playerUUID', playerUUID);
                        }
                    }
                    
                    console.log('Auth initialized, playerUUID:', playerUUID);
                    resolve();
                });
            });
        }

        async function joinLobbyFromURL() {
            const params = new URLSearchParams(window.location.search);
            lobbyId = params.get('lobbyId');
            
            if (!lobbyId) {
                console.warn('No lobby ID found in URL. Redirecting to lobby page...');
                window.location.href = '../../lobby.html';
                return false;
            }

            try {
                // Join the lobby using the helper function (adds us to players list)
                console.log('Joining lobby via URL:', lobbyId);
                
                // Get the username from sessionStorage (set when player entered lobby)
                const username = sessionStorage.getItem('playerUsername') || sessionStorage.getItem('currentPlayerName');
                console.log('Joining with username:', username);
                
                const result = await joinLobby(lobbyId, username);
                
                // Update playerUUID from the result
                if (result && result.playerId) {
                    playerUUID = result.playerId;
                    sessionStorage.setItem('playerUUID', playerUUID);
                }
                
                // Store locally for later use
                window.currentLobbyId = lobbyId;
                sessionStorage.setItem('currentLobbyId', lobbyId);
                
                // Fetch lobby data to get the key
                const lobbySnapshot = await db.ref(`lobbies/${lobbyId}`).once('value');
                const lobbyData = lobbySnapshot.val();
                
                if (lobbyData && lobbyData.key) {
                    currentLobbyKey = lobbyData.key;
                    document.getElementById('lobby-code-display').textContent = currentLobbyKey;
                } else {
                    document.getElementById('lobby-code-display').textContent = lobbyId.slice(0, 6);
                }
                
                // Initialize players from lobby
                lobbyPlayers = lobbyData.players || {};
                
                // Initialize chips only if missing; preserve 0 so bankruptcy rules can apply
                const playerRef = db.ref(`lobbies/${lobbyId}/players/${playerUUID}`);
                const playerSnapshot = await playerRef.once('value');
                const playerData = playerSnapshot.val();
                
                if (playerData && playerData.chips === undefined) {
                    await playerRef.update({ chips: STARTING_CHIPS });
                }
                
                console.log('Successfully joined lobby, key:', currentLobbyKey, 'playerUUID:', playerUUID);
                return true;
            } catch (error) {
                console.error('Error joining lobby from URL:', error);
                showToast('Error joining lobby: ' + error.message);
                setTimeout(() => {
                    window.location.href = '../../lobby.html';
                }, 2000);
                return false;
            }
        }

        function setupRealtimeSync() {
            if (!lobbyId) {
                console.error('No lobbyId set, cannot setup sync');
                return;
            }

            console.log('Setting up real-time sync for lobby:', lobbyId);
            
            // Attach lobby listener
            lobbyRef = onLobbyUpdate((data) => {
                if (!data) {
                    console.warn('No data received from onLobbyUpdate');
                    return;
                }

                console.log('Lobby data updated:', data);
                
                // Update players list
                lobbyPlayers = data.players || {};
                
                // Update match state (game-specific)
                const gameState = data.gameStates && data.gameStates[GAME_TYPE];
                if (gameState) {
                    currentMatchState = gameState;
                    
                    // Ensure playerStates object exists
                    if (!currentMatchState.playerStates) {
                        currentMatchState.playerStates = {};
                    }
                    
                    // Initialize player states for any new players
                    Object.keys(lobbyPlayers).forEach(playerId => {
                        if (!currentMatchState.playerStates[playerId]) {
                            const sittingOut = isPlayerSittingOut(lobbyPlayers[playerId]);
                            currentMatchState.playerStates[playerId] = {
                                ready: lobbyPlayers[playerId].isBot ? true : sittingOut,
                                score: 0,
                                sittingOut
                            };
                        }
                    });
                } else {
                    currentMatchState = currentMatchState || {};
                    if (!currentMatchState.playerStates) {
                        currentMatchState.playerStates = {};
                    }
                }
                
                // Update player chips from Firebase
                Object.entries(lobbyPlayers).forEach(([pid, player]) => {
                    const chips = Number(player?.chips);
                    playerChips[pid] = Number.isFinite(chips) ? chips : STARTING_CHIPS;
                });
                
                console.log('Players in lobby:', Object.keys(lobbyPlayers).length, lobbyPlayers);
                console.log('Match state:', currentMatchState);
                
                // Update UI
                syncFromFirebase(currentMatchState);
                updatePlayerList();
                handleTurnLogic();
                updateGameStatus();
                updatePotDisplay();
                updateReadySection();
                
                // Host should check if all players are ready during waiting phase
                if (isHostClient() && currentMatchState && currentMatchState.status === 'waiting' && !isReadyCheckInProgress) {
                    checkAllPlayersReady();
                }
                
                // Host should check if betting phase is complete whenever state updates (with debounce)
                if (isHostClient() && currentMatchState && currentMatchState.status === 'betting' && !isBettingCheckInProgress) {
                    checkBettingPhaseComplete();
                }
                
                // Host should check if rolling phase is complete whenever state updates (with debounce)
                if (isHostClient() && currentMatchState && currentMatchState.status === 'playing' && !isRollingCheckInProgress) {
                    checkRollingPhaseComplete();
                }
                
                // Initialize game on first load
                checkAndStartGame();
            }, lobbyId);
            
            window.globalLobbyRef = lobbyRef;
        }

        function checkAndStartGame() {
            // Initialize match state if it doesn't exist yet
            console.log('checkAndStartGame - currentMatchState:', currentMatchState, 'Object.keys.length:', Object.keys(currentMatchState || {}).length, 'gameInitialized:', gameInitialized);
            
            if (!currentMatchState || Object.keys(currentMatchState).length === 0) {
                // Try to initialize if we're the host
                const realPlayers = Object.entries(lobbyPlayers).filter(([_, p]) => !p.isBot);
                console.log('No game state yet - realPlayers:', realPlayers.length, 'isHostClient:', isHostClient());
                if (isHostClient() && !gameInitialized && realPlayers.length >= 2) {
                    console.log('First time setup - starting game round with waiting status');
                    gameInitialized = true;
                    startGameRound().catch(err => {
                        console.error('startGameRound failed:', err);
                        gameInitialized = false;
                    });
                }
            } else if (currentMatchState && currentMatchState.status === 'waiting' && !gameInitialized) {
                const realPlayers = Object.values(lobbyPlayers).filter(p => !p.isBot);
                console.log('Game in waiting state - realPlayers:', realPlayers.length);
                if (realPlayers.length > 0) {
                    console.log('Game entered waiting state with players. Showing ready-up UI.');
                    gameInitialized = true;
                }
            } else if (currentMatchState && !currentMatchState.status && !gameInitialized && Object.keys(lobbyPlayers).length >= 2) {
                // Fallback: if game state exists but has no status after 2+ players, force it to waiting
                console.log('Game state exists but no status - forcing to waiting mode');
                gameInitialized = true;
                // Force update to waiting if we're the host
                if (isHostClient()) {
                    const { turnPlayers, playerStates, updates } = buildNextRoundSetup(lobbyPlayers);
                    db.ref(`lobbies/${lobbyId}`).update(updates)
                        .then(() => updateGameSpecificState(GAME_TYPE, {
                            status: 'waiting',
                            turnOrder: turnPlayers,
                            currentTurn: turnPlayers[0] || null,
                            playerStates: playerStates
                        }, lobbyId))
                        .catch(err => console.error('Force update failed:', err));
                }
            }
        }

        function updateReadySection() {
            const readySection = document.getElementById('ready-section');
            const waitingDisplay = document.getElementById('waiting-on-display');
            const readyBtn = document.getElementById('ready-btn');
            
            console.log('updateReadySection - currentMatchState:', currentMatchState, 'status:', currentMatchState?.status);
            
            if (!currentMatchState || currentMatchState.status !== 'waiting') {
                if (readySection) readySection.style.display = 'none';
                return;
            }
            
            if (readySection) readySection.style.display = 'block';
            
            // Get list of human players who are not ready
            const playerStates = currentMatchState.playerStates || {};
            const notReadyPlayers = [];
            const sittingOutPlayers = [];
            const iAmSittingOut = isPlayerSittingOut(lobbyPlayers[playerUUID]);
            
            Object.entries(lobbyPlayers).forEach(([playerId, player]) => {
                if (!player.isBot) {
                    if (isPlayerSittingOut(player)) {
                        const rounds = getSitOutRoundsRemaining(player);
                        sittingOutPlayers.push(`${player.name || `Player-${playerId.slice(0, 4)}`} (${rounds} left)`);
                        return;
                    }
                    const playerState = playerStates[playerId] || {};
                    if (!playerState.ready) {
                        notReadyPlayers.push(player.name || `Player-${playerId.slice(0, 4)}`);
                    }
                }
            });
            
            // Update waiting display
            if (notReadyPlayers.length === 0) {
                const sitOutSuffix = sittingOutPlayers.length
                    ? `<br><span style="color: #aab7b8;">Sitting out: ${sittingOutPlayers.join(', ')}</span>`
                    : '';
                waitingDisplay.innerHTML = `<span style="color: #27ae60; font-weight: bold;">All active players ready! Starting game...</span>${sitOutSuffix}`;
                if (readyBtn) readyBtn.disabled = true;
            } else {
                const isCurrentPlayerReady = (playerStates[playerUUID] || {}).ready;
                const sitOutSuffix = sittingOutPlayers.length
                    ? `<br><span style="color: #aab7b8;">Sitting out: ${sittingOutPlayers.join(', ')}</span>`
                    : '';
                waitingDisplay.innerHTML = `Waiting on: <strong>${notReadyPlayers.join(', ')}</strong>${sitOutSuffix}`;
                if (readyBtn) readyBtn.disabled = iAmSittingOut || isCurrentPlayerReady;
            }

            if (readyBtn) {
                if (iAmSittingOut) {
                    const rounds = getSitOutRoundsRemaining(lobbyPlayers[playerUUID]);
                    readyBtn.textContent = `‚è∏ Sitting Out (${rounds})`;
                } else {
                    readyBtn.textContent = '‚úì Ready';
                }
            }
        }

        async function markPlayerReady() {
            if (!lobbyId || !playerUUID) return;
            if (isPlayerSittingOut(lobbyPlayers[playerUUID])) {
                const rounds = getSitOutRoundsRemaining(lobbyPlayers[playerUUID]);
                showToast(`You are sitting out this round (${rounds} remaining).`);
                const readyBtn = document.getElementById('ready-btn');
                if (readyBtn) readyBtn.disabled = true;
                return;
            }
            
            try {
                // Update player ready status in Firebase
                await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}/playerStates/${playerUUID}`).update({
                    ready: true
                });
                
                console.log('Player marked as ready');
                showToast('You are ready!');
                
                // Disable the button
                document.getElementById('ready-btn').disabled = true;
                
                // Check if all humans are ready (host will auto-transition)
                if (isHostClient()) {
                    setTimeout(checkAllPlayersReady, 500);
                }
            } catch (error) {
                console.error('Error marking player ready:', error);
                showToast('Error marking ready');
            }
        }

        async function checkAllPlayersReady() {
            if (!currentMatchState || currentMatchState.status !== 'waiting') return;
            if (!isHostClient()) return;
            if (isReadyCheckInProgress) return;
            
            isReadyCheckInProgress = true;
            
            try {
                const playerStates = currentMatchState.playerStates || {};
                
                // Check if all human players are ready
                const allHumansReady = Object.entries(lobbyPlayers).every(([playerId, player]) => {
                    if (player.isBot) return true; // Bots are always ready
                    if (isPlayerSittingOut(player)) return true;
                    const state = playerStates[playerId] || {};
                    return state.ready === true;
                });
                
                if (allHumansReady) {
                    const activeTurnCount = (currentMatchState.turnOrder || []).length;
                    if (activeTurnCount === 0) {
                        console.log('All active players are currently sitting out. Waiting for rejoin rounds.');
                        return;
                    }
                    console.log('All humans ready! Transitioning to betting phase...');
                    await startBettingPhase();
                }
            } finally {
                isReadyCheckInProgress = false;
            }
        }

        function getPlayerChipsValue(player) {
            const chips = Number(player?.chips);
            return Number.isFinite(chips) ? chips : STARTING_CHIPS;
        }

        function getSitOutRoundsRemaining(player) {
            const rounds = Number(player?.sitOutRoundsRemaining);
            if (!Number.isFinite(rounds) || rounds <= 0) return 0;
            return Math.floor(rounds);
        }

        function isPlayerSittingOut(player) {
            if (!player || player.isBot) return false;
            return getSitOutRoundsRemaining(player) > 0;
        }

        function willPlayerSitOutNextRound(playerLike) {
            if (!playerLike || playerLike.isBot) return false;
            const sitOutRoundsRemaining = getSitOutRoundsRemaining(playerLike);
            if (sitOutRoundsRemaining > 0) return true;
            return getPlayerChipsValue(playerLike) <= 0;
        }

        function buildNextRoundSetup(playersData) {
            const turnPlayers = [];
            const playerStates = {};
            const updates = {};

            Object.entries(playersData || {}).forEach(([playerId, player]) => {
                const isBot = !!player?.isBot;
                let chips = getPlayerChipsValue(player);
                let sitOutRoundsRemaining = isBot ? 0 : getSitOutRoundsRemaining(player);

                if (!isBot) {
                    if (sitOutRoundsRemaining > 0) {
                        sitOutRoundsRemaining -= 1;
                        if (sitOutRoundsRemaining === 0) {
                            chips = STARTING_CHIPS;
                        }
                    } else if (chips <= 0) {
                        sitOutRoundsRemaining = BANKRUPT_SIT_OUT_ROUNDS;
                    }
                }

                const sittingOut = !isBot && sitOutRoundsRemaining > 0;

                if (!sittingOut) {
                    turnPlayers.push(playerId);
                }

                playerStates[playerId] = {
                    ready: isBot || sittingOut,
                    score: 0,
                    sittingOut
                };

                updates[`players/${playerId}/chips`] = chips;
                updates[`players/${playerId}/score`] = 0;
                updates[`players/${playerId}/sitOutRoundsRemaining`] = sitOutRoundsRemaining;
            });

            return { turnPlayers, playerStates, updates };
        }

        function getPlayerDisplayName(playerId) {
            if (!playerId) return 'Player';
            const player = lobbyPlayers[playerId];
            return player ? (player.name || 'Player') : 'Player';
        }

        function getSpectatorActionText(lastAction) {
            if (!lastAction || !lastAction.type) return 'Watching live turn...';

            if (lastAction.type === 'turn_start') return 'Turn started';
            if (lastAction.type === 'hold_toggle') return 'Updated held dice';
            if (lastAction.type === 'roll') {
                const rolls = lastAction.rollsLeft;
                return typeof rolls === 'number' ? `Rolled dice (${rolls} rolls left)` : 'Rolled dice';
            }
            if (lastAction.type === 'end_turn') return 'Ended turn';
            return 'Watching live turn...';
        }

        function buildInitialSpectatorView(playerId) {
            return {
                playerId,
                playerName: getPlayerDisplayName(playerId),
                dice: [0, 0, 0, 0, 0],
                heldDice: [false, false, false, false, false],
                rollsLeft: 2,
                score: 0,
                handName: 'Roll to see your hand!',
                updatedAt: Date.now()
            };
        }

        function applySpectatorViewState(viewState) {
            if (!viewState) return;
            if (!Array.isArray(viewState.dice) || viewState.dice.length !== 5) return;
            if (!Array.isArray(viewState.heldDice) || viewState.heldDice.length !== 5) return;

            if (spectatorView && spectatorView.playerId !== viewState.playerId) {
                lastAppliedSpectatorUpdatedAt = 0;
            }

            const updatedAt = Number(viewState.updatedAt) || 0;
            if (updatedAt && updatedAt < lastAppliedSpectatorUpdatedAt) return;
            if (updatedAt) lastAppliedSpectatorUpdatedAt = updatedAt;

            dice = [...viewState.dice];
            heldDice = [...viewState.heldDice];
            rollsLeft = typeof viewState.rollsLeft === 'number' ? viewState.rollsLeft : 2;
            currentScore = typeof viewState.score === 'number' ? viewState.score : 0;

            document.getElementById('rolls-left').textContent = rollsLeft;
            document.getElementById('current-score').textContent = currentScore;
            document.getElementById('hand-result').textContent = viewState.handName || 'Roll to see your hand!';
            renderDice();
        }

        function updateSpectatingBanner() {
            const banner = document.getElementById('spectating-banner');
            const rollBtn = document.getElementById('roll-btn');
            const endTurnBtn = document.getElementById('end-turn-btn');

            if (!banner || !rollBtn || !endTurnBtn) return;

            rollBtn.textContent = 'üé≤ Roll Dice';
            endTurnBtn.textContent = '‚úì End Turn';

            if (!currentMatchState || currentMatchState.status !== 'playing' || !currentMatchState.currentTurn) {
                banner.style.display = 'none';
                return;
            }

            const isMyTurn = currentMatchState.currentTurn === playerUUID;
            if (isMyTurn && !playerTurnComplete && !hasFolded) {
                banner.style.display = 'none';
                return;
            }

            const targetPlayerId = currentMatchState.currentTurn;
            const targetName = getPlayerDisplayName(targetPlayerId);
            const lastAction = currentMatchState.lastAction || {};
            const actionText = lastAction.playerId === targetPlayerId
                ? getSpectatorActionText(lastAction)
                : 'Watching live turn...';

            banner.style.display = 'block';
            banner.innerHTML = `üëÄ Spectating <strong>${targetName}</strong><span class="subtext">${actionText}</span>`;

            rollBtn.textContent = `üëÄ Spectating ${targetName}`;
            endTurnBtn.textContent = '‚åõ Waiting...';
        }

        async function syncSpectatorView(actionType) {
            if (!lobbyId || !currentMatchState || currentMatchState.status !== 'playing') return;
            if (currentMatchState.currentTurn !== playerUUID) return;

            const viewState = {
                playerId: playerUUID,
                playerName: getPlayerDisplayName(playerUUID),
                dice: [...dice],
                heldDice: [...heldDice],
                rollsLeft,
                score: currentScore,
                handName: document.getElementById('hand-result').textContent || 'Roll to see your hand!',
                updatedAt: Date.now()
            };

            const lastAction = {
                type: actionType,
                playerId: playerUUID,
                playerName: getPlayerDisplayName(playerUUID),
                rollsLeft,
                updatedAt: viewState.updatedAt
            };

            spectatorView = viewState;

            try {
                await updateGameSpecificState(GAME_TYPE, {
                    spectatorView: viewState,
                    lastAction: lastAction
                }, lobbyId);
            } catch (error) {
                console.error('Failed to sync spectator view:', error);
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function clearBotActionSchedule() {
            if (botActionTimeout) {
                clearTimeout(botActionTimeout);
            }
            botActionTimeout = null;
            botActionKey = null;
            botActionInProgressKey = null;
        }

        function scheduleBotAction(phase, botId, delayMs) {
            if (!isHostClient() || !botId) return;

            const round = currentMatchState?.round || 0;
            const key = `${phase}:${round}:${botId}`;
            if (botActionInProgressKey === key) return;
            if (botActionKey === key && botActionTimeout) return;

            clearBotActionSchedule();
            botActionKey = key;

            botActionTimeout = setTimeout(async () => {
                botActionTimeout = null;
                const expectedKey = key;
                if (botActionKey !== expectedKey) return;

                botActionInProgressKey = expectedKey;

                try {
                    if (phase === 'betting') {
                        await runBotBet(botId);
                    } else {
                        await runBotRoll(botId);
                    }
                } finally {
                    if (botActionInProgressKey === expectedKey) {
                        botActionInProgressKey = null;
                    }
                    if (botActionKey === expectedKey) {
                        botActionKey = null;
                    }
                }
            }, delayMs);
        }

        function handleTurnLogic() {
            if (!currentMatchState) {
                console.log('No match state defined');
                clearBotActionSchedule();
                return;
            }
            
            console.log('handleTurnLogic - status:', currentMatchState.status, 'currentTurn:', currentMatchState.currentTurn, 'myUUID:', playerUUID);
            
            // If game is not in an active phase, don't process turn logic
            if (!currentMatchState.status || (currentMatchState.status !== 'betting' && currentMatchState.status !== 'playing')) {
                console.log('Game not in active phase, status:', currentMatchState.status);
                clearBotActionSchedule();
                return;
            }
            
            // If currentTurn is not set but we're in betting/playing, wait and retry
            if (!currentMatchState.currentTurn) {
                console.log('No current turn defined yet, retrying...');
                clearBotActionSchedule();
                setTimeout(handleTurnLogic, 500);
                return;
            }
            
            const isMyTurn = currentMatchState.currentTurn === playerUUID;
            const currentPlayer = lobbyPlayers[currentMatchState.currentTurn];
            
            console.log('isMyTurn:', isMyTurn, 'currentPlayer:', currentPlayer?.name, 'myName:', lobbyPlayers[playerUUID]?.name);
            
            // Reset turn complete flag when it becomes our turn
            if (isMyTurn && playerTurnComplete) {
                console.log('It is now my turn - resetting playerTurnComplete flag');
                playerTurnComplete = false;
            }
            
            if (currentMatchState.status === 'betting') {
                console.log('Betting phase - isMyTurn:', isMyTurn);
                // Only allow betting controls during betting phase
                if (isMyTurn && !hasFolded) {
                    enableBettingControls();
                    showToast("Your turn to bet!");
                } else {
                    disableBettingControls();
                }
                // Bot betting
                if (isHostClient() && currentPlayer && currentPlayer.isBot) {
                    scheduleBotAction('betting', currentMatchState.currentTurn, BOT_BET_DELAY_MS);
                } else {
                    clearBotActionSchedule();
                }
                disableRollingControls();
                return;
            }

            // After betting phase, only rolling and gameplay actions should be enabled
            disableBettingControls();
            if (currentMatchState.status === 'playing') {
                console.log('Playing phase - isMyTurn:', isMyTurn, 'playerTurnComplete:', playerTurnComplete);
                bettingStarted = false;
                if (isMyTurn && !hasFolded && !playerTurnComplete) {
                    if (preparedRollingTurnId !== currentMatchState.currentTurn) {
                        resetTurn();
                        preparedRollingTurnId = currentMatchState.currentTurn;
                        syncSpectatorView('turn_start');
                    }
                    const canRoll = rollsLeft > 0;
                    document.getElementById('roll-btn').disabled = !canRoll;
                    document.getElementById('end-turn-btn').disabled = canRoll;
                    renderDice();
                    showToast("Your turn to roll!");
                } else {
                    preparedRollingTurnId = null;
                    disableControls();

                    const remoteView = currentMatchState.spectatorView;
                    const currentTurnId = currentMatchState.currentTurn;
                    if (remoteView && remoteView.playerId === currentTurnId) {
                        applySpectatorViewState(remoteView);
                    }
                }
                // Bot rolling
                if (isHostClient() && currentPlayer && currentPlayer.isBot) {
                    scheduleBotAction('playing', currentMatchState.currentTurn, BOT_BET_DELAY_MS);
                } else {
                    clearBotActionSchedule();
                }
                updateSpectatingBanner();
                return;
            }
        }

        function syncFromFirebase(matchState) {
            if (!matchState) return;
            
            if (matchState.pot !== undefined) {
                currentPot = matchState.pot;
            }
            
            if (matchState.currentBet !== undefined) {
                currentBet = matchState.currentBet;
                firstPlayerBet = matchState.currentBet;
                updateBetDisplay();
            }

            if (matchState.lastRaiseSize !== undefined) {
                lastRaiseSize = matchState.lastRaiseSize;
            }
            
            if (matchState.bettingStarter) {
                bettingStarter = matchState.bettingStarter;
            }

            spectatorView = matchState.spectatorView || null;

            if (matchState.status === 'waiting') {
                scoreboardShown = false;
                gameStarted = false;
                hasFolded = false;
                bettingStarted = false;
                bettingStarter = null;
                playerTurnComplete = false;
                preparedRollingTurnId = null;
                spectatorView = null;
                lastAppliedSpectatorUpdatedAt = 0;
                rollsLeft = 2;
                currentScore = 0;
                dice = [0, 0, 0, 0, 0];
                heldDice = [false, false, false, false, false];
                renderDice();

                const scoreboardModal = document.getElementById('scoreboardModal');
                if (scoreboardModal) {
                    scoreboardModal.classList.remove('active');
                }
            }

            if (matchState.status === 'betting') {
                preparedRollingTurnId = null;
                spectatorView = null;
                lastAppliedSpectatorUpdatedAt = 0;
                updateSpectatingBanner();
            }

            if (matchState.status === 'playing') {
                const isMyTurn = matchState.currentTurn === playerUUID;
                if (!isMyTurn && spectatorView && spectatorView.playerId === matchState.currentTurn) {
                    applySpectatorViewState(spectatorView);
                }
                updateSpectatingBanner();
            }

            if (matchState.status === 'finished') {
                preparedRollingTurnId = null;
                lastAppliedSpectatorUpdatedAt = 0;
                updateSpectatingBanner();
            }

            if (matchState.status === 'finished') {
                updateScoreboardReadyStatus();
                if (isHostClient()) {
                    checkAllNextRoundReady();
                }
            }
            
            if (matchState.gameOver && !scoreboardShown) {
                const rankings = matchState.rankings || [];
                const winner = matchState.winner;
                showScoreboard(rankings, winner);
            }
        }

        function updatePlayerList() {
            const container = document.getElementById('player-list-container');
            if (!container) {
                console.error('player-list-container not found!');
                return;
            }
            
            console.log('Updating player list, lobbyPlayers:', lobbyPlayers);
            container.innerHTML = '';

            if (Object.keys(lobbyPlayers).length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted);">No players yet...</p>';
                console.warn('No players found in lobby');
                return;
            }

            const matchState = currentMatchState || {};
            
            // Display all players in order
            Object.entries(lobbyPlayers).forEach(([playerId, player]) => {
                const isCurrentTurn = matchState.currentTurn === playerId;
                const playerFolded = matchState.folded && matchState.folded[playerId];
                const playerStates = matchState.playerStates || {};
                const playerState = playerStates[playerId] || {};
                const isMe = playerId === playerUUID;
                const sitOutRounds = getSitOutRoundsRemaining(player);
                const isSittingOut = !player.isBot && sitOutRounds > 0;
                
                const card = document.createElement('div');
                card.className = `player-card ${isCurrentTurn ? 'active-turn' : ''} ${playerFolded ? 'folded' : ''}`;
                
                const avatar = player.isBot ? 'ü§ñ' : 'üë§';
                const turnIndicator = isCurrentTurn ? '<span class="turn-indicator">‚óÄ</span>' : '';
                const foldedText = playerFolded ? ' (FOLDED)' : '';
                const chips = getPlayerChipsValue(player);
                const readyBadge = (matchState.status === 'waiting' && playerState.ready && !player.isBot && !isSittingOut) ? '<span class="ready-badge">‚úì Ready</span>' : '';
                const sitOutBadge = isSittingOut ? `<span class="ready-badge" style="background: #e67e22;">‚è∏ Sit Out (${sitOutRounds})</span>` : '';
                const youText = isMe ? ' (You)' : '';
                const handText = isSittingOut ? `Sitting out (${sitOutRounds} round${sitOutRounds === 1 ? '' : 's'} left)` : (getHandName(player.score) || 'Waiting');
                
                card.innerHTML = `
                    <div class="player-avatar ${player.isBot ? 'bot' : ''}">${avatar}</div>
                    <div class="player-info">
                        <div class="player-name">${player.name || 'Unknown'}${youText}${foldedText}</div>
                        <div class="player-score">${isSittingOut ? handText : `Hand: ${handText}`}</div>
                        <div class="player-chips">Chips: ${chips}</div>
                        ${readyBadge}
                        ${sitOutBadge}
                    </div>
                    ${turnIndicator}
                `;
                
                container.appendChild(card);
            });
        }

        function updateGameStatus() {
            const statusEl = document.getElementById('game-status');
            
            if (!currentMatchState || !currentMatchState.status || currentMatchState.status === 'waiting') {
                const playerCount = Object.keys(lobbyPlayers).length;
                statusEl.textContent = playerCount > 0 ? `‚è≥ Starting game... (${playerCount} players)` : 'Waiting for players...';
            } else if (currentMatchState.status === 'betting') {
                const isMyTurn = currentMatchState.currentTurn === playerUUID;
                if (isMyTurn && !hasFolded) {
                    statusEl.textContent = "üí∞ Your Turn - Place Your Bet!";
                } else {
                    const currentPlayer = lobbyPlayers[currentMatchState.currentTurn];
                    const playerName = currentPlayer ? currentPlayer.name : 'Player';
                    statusEl.textContent = `‚è≥ Waiting for ${playerName} to bet...`;
                }
            } else if (currentMatchState.status === 'playing') {
                const isMyTurn = currentMatchState.currentTurn === playerUUID;
                if (isMyTurn && !hasFolded) {
                    statusEl.textContent = "üé≤ Your Turn - Roll the Dice!";
                } else {
                    const currentPlayer = lobbyPlayers[currentMatchState.currentTurn];
                    const playerName = currentPlayer ? currentPlayer.name : 'Player';
                    statusEl.textContent = `üëÄ Spectating ${playerName} - live turn in progress`;
                }
            }

            updateSpectatingBanner();
        }

        function updatePotDisplay() {
            const potDisplay = document.getElementById('pot-display');
            const potValue = document.getElementById('pot-value');
            
            if (currentPot > 0) {
                potDisplay.style.display = 'block';
                potValue.textContent = currentPot;
            } else {
                potDisplay.style.display = 'none';
            }
        }

        // ==============================
        // GAME INITIALIZATION & FLOW
        // ==============================
        async function startGameRound() {
            // Only host should call this, and only once
            if (!lobbyId || !db) return;
            
            console.log('startGameRound called - isHostClient:', isHostClient(), 'gameInitialized:', gameInitialized);
            
            // Check if game-specific state already exists
            const snapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
            if (snapshot.exists()) {
                console.log('Game state already initialized, skipping startGameRound');
                return;
            }
            
            // Only proceed if this player is the host
            if (!isHostClient()) {
                console.log('Not host client, skipping match state initialization');
                return;
            }
            
            console.log('Starting new game round as host');
            hasFolded = false;
            const { turnPlayers, playerStates, updates } = buildNextRoundSetup(lobbyPlayers);
            
            // Update match state to waiting (for ready-up) - use game-specific namespace
            const matchStateUpdate = {
                status: 'waiting',
                round: (currentMatchState && currentMatchState.round) ? currentMatchState.round + 1 : 1,
                turnOrder: turnPlayers,
                currentTurn: turnPlayers[0] || null,
                pot: 0,
                currentBet: 0,
                lastRaiseSize: 50,
                playerBets: {},
                allIn: {},
                folded: {},
                completedBetting: {},
                completedRolling: {},
                playerStates: playerStates,
                nextRoundReady: {},
                spectatorView: null,
                lastAction: null,
                finishLocked: false,
                gameOver: false,
                winner: null,
                rankings: null
            };
            
            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, matchStateUpdate, lobbyId);
            
            console.log('Match state initialized with waiting status for ready-up');
        }

        async function startBettingPhase() {
            if (!lobbyId || !db) {
                console.error('Missing lobbyId or db in startBettingPhase');
                return;
            }
            if (!isHostClient()) {
                console.log('Not host client, skipping startBettingPhase');
                return;
            }
            
            console.log('All players ready! Starting betting phase...');
            console.log('Current lobbyPlayers:', lobbyPlayers);
            
            // Build a stable turn order if missing
            const orderedPlayers = (currentMatchState && currentMatchState.turnOrder && currentMatchState.turnOrder.length)
                ? currentMatchState.turnOrder
                : Object.keys(lobbyPlayers).filter(pid => !isPlayerSittingOut(lobbyPlayers[pid]));

            const activeOrderedPlayers = orderedPlayers.filter(pid => !isPlayerSittingOut(lobbyPlayers[pid]));
            if (!activeOrderedPlayers.length) {
                console.warn('No active players available to start betting phase.');
                return;
            }

            console.log('Ordered players:', activeOrderedPlayers);

            // Find the first human (non-bot) player in turn order
            let firstHuman = null;
            if (activeOrderedPlayers && activeOrderedPlayers.length) {
                for (const pid of activeOrderedPlayers) {
                    console.log('Checking player:', pid, 'isBot:', lobbyPlayers[pid]?.isBot);
                    if (lobbyPlayers[pid] && !lobbyPlayers[pid].isBot) {
                        firstHuman = pid;
                        console.log('Found first human:', firstHuman);
                        break;
                    }
                }
            }
            
            // Fallback to first in turnOrder if no humans (shouldn't happen)
            const initialTurn = firstHuman || (activeOrderedPlayers && activeOrderedPlayers[0]) || null;
            
            if (!initialTurn) {
                console.error('No initial turn player found!');
                return;
            }
            
            console.log('Initial turn will be:', initialTurn, 'Player name:', lobbyPlayers[initialTurn]?.name);
            
            // Transition from waiting to betting with full state reset
            const betPhaseUpdate = {
                status: 'betting',
                turnOrder: activeOrderedPlayers,
                currentTurn: initialTurn,
                pot: 0,
                currentBet: 0,
                firstPlayerBet: 0,
                lastRaiseSize: 50,
                playerBets: {},
                allIn: {},
                folded: {},
                completedBetting: {},
                completedRolling: {},
                spectatorView: null,
                lastAction: null
            };
            
            // Update Firebase and wait for completion
            console.log('Updating Firebase with betting phase, initialTurn:', initialTurn);
            try {
                await updateGameSpecificState(GAME_TYPE, betPhaseUpdate, lobbyId);
                console.log('Firebase updated successfully with status=betting and currentTurn=', initialTurn);
            } catch (error) {
                console.error('Error updating Firebase:', error);
                return;
            }
            
            // Don't update local state immediately - let Firebase propagation handle it
            // This ensures all clients get the same state at the same time
            showToast('Game started! First player to bet...');
        }

        // ==============================
        // BETTING LOGIC
        // ==============================
        const OPENING_BET_MIN = 50;

        function getPlayerContribution(state, playerId) {
            return Number((state.playerBets || {})[playerId]) || 0;
        }

        function getCallAmountForPlayer(state, playerId) {
            const tableBet = Number(state.currentBet) || 0;
            const playerContribution = getPlayerContribution(state, playerId);
            return Math.max(0, tableBet - playerContribution);
        }

        function getMinimumRaiseTarget(state) {
            const tableBet = Number(state.currentBet) || 0;
            const minimumRaiseSize = Math.max(Number(state.lastRaiseSize) || OPENING_BET_MIN, 1);
            return tableBet + minimumRaiseSize;
        }

        function getMyChipCount() {
            const chips = Number(playerChips[playerUUID]);
            return Number.isFinite(chips) ? chips : STARTING_CHIPS;
        }

        function getMyMaxBetTarget(state) {
            return getPlayerContribution(state, playerUUID) + getMyChipCount();
        }

        function clampPendingRaiseTarget(state) {
            const minimumTarget = getMinimumRaiseTarget(state);
            const maximumTarget = getMyMaxBetTarget(state);
            if (maximumTarget < minimumTarget) {
                pendingRaiseTarget = maximumTarget;
            } else {
                pendingRaiseTarget = Math.min(Math.max(pendingRaiseTarget, minimumTarget), maximumTarget);
            }
        }

        function adjustBet(amount) {
            if (!currentMatchState || currentMatchState.status !== 'betting') return;

            const hasOpeningBet = !!currentMatchState.bettingStarter && (Number(currentMatchState.currentBet) || 0) > 0;
            if (!hasOpeningBet) {
                const myChips = getMyChipCount();
                const newTarget = pendingRaiseTarget + amount;
                if (newTarget >= OPENING_BET_MIN && newTarget <= myChips) {
                    pendingRaiseTarget = newTarget;
                    enableBettingControls();
                }
                return;
            }

            const myMaxTarget = getMyMaxBetTarget(currentMatchState);
            if (myMaxTarget <= (Number(currentMatchState.currentBet) || 0)) return;
            const newTarget = pendingRaiseTarget + amount;
            pendingRaiseTarget = newTarget;
            clampPendingRaiseTarget(currentMatchState);
            enableBettingControls();
        }

        function resetBet() {
            if (!currentMatchState || currentMatchState.status !== 'betting') {
                pendingRaiseTarget = OPENING_BET_MIN;
                updateBetDisplay();
                return;
            }

            const hasOpeningBet = !!currentMatchState.bettingStarter && (Number(currentMatchState.currentBet) || 0) > 0;
            if (!hasOpeningBet) {
                pendingRaiseTarget = OPENING_BET_MIN;
            } else {
                pendingRaiseTarget = getMinimumRaiseTarget(currentMatchState);
                clampPendingRaiseTarget(currentMatchState);
            }

            enableBettingControls();
        }

        function updateBetDisplay() {
            document.getElementById('bet-display').textContent = currentBet;
            const myChips = Number(playerChips[playerUUID]);
            document.getElementById('player-chips').textContent = Number.isFinite(myChips) ? myChips : STARTING_CHIPS;
        }

        function enableBettingControls() {
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'block';
            }
            
            const bettingControls = document.getElementById('betting-controls');
            const callConfirmation = document.getElementById('call-confirmation');
            const placeBetBtn = document.getElementById('place-bet-btn');
            const raiseBtn = document.getElementById('raise-btn');
            const minRaiseDisplay = document.getElementById('min-raise-display');

            const hasOpeningBet = !!currentMatchState.bettingStarter && (Number(currentMatchState.currentBet) || 0) > 0;
            const callAmount = getCallAmountForPlayer(currentMatchState, playerUUID);
            const myMaxTarget = getMyMaxBetTarget(currentMatchState);
            const minimumRaiseTarget = getMinimumRaiseTarget(currentMatchState);
            const canRaise = hasOpeningBet && myMaxTarget >= minimumRaiseTarget;

            if (!hasOpeningBet) {
                pendingRaiseTarget = Math.min(Math.max(pendingRaiseTarget, OPENING_BET_MIN), getMyChipCount());
            } else {
                clampPendingRaiseTarget(currentMatchState);
            }

            if (bettingControls) bettingControls.style.display = (!hasOpeningBet || canRaise) ? 'flex' : 'none';

            if (callConfirmation) {
                callConfirmation.style.display = 'block';
                document.getElementById('call-amount-display').textContent = callAmount;

                if (!hasOpeningBet) {
                    minRaiseDisplay.textContent = `Opening bet: ${pendingRaiseTarget}`;
                } else if (canRaise) {
                    minRaiseDisplay.textContent = `Raise to at least ${minimumRaiseTarget} (selected: ${pendingRaiseTarget})`;
                } else {
                    minRaiseDisplay.textContent = 'You do not have enough chips for a legal raise target.';
                }
            }

            if (placeBetBtn) {
                if (!hasOpeningBet) {
                    placeBetBtn.textContent = 'üí∞ Open Bet';
                } else if (callAmount > 0) {
                    placeBetBtn.textContent = 'üí∞ Call';
                } else {
                    placeBetBtn.textContent = '‚úì Check';
                }
            }

            if (raiseBtn) {
                raiseBtn.disabled = !canRaise;
            }

            updateBetDisplay();
        }

        function disableBettingControls() {
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'none';
            }
        }

        async function placeBet() {
            if (!lobbyId || !playerUUID) return;

            const stateSnapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
            const state = stateSnapshot.val() || {};
            if (state.status !== 'betting' || state.currentTurn !== playerUUID) return;

            const myChips = getMyChipCount();
            const tableBet = Number(state.currentBet) || 0;
            const myContribution = getPlayerContribution(state, playerUUID);
            const hasOpeningBet = !!state.bettingStarter && tableBet > 0;

            const updates = {};
            const stateUpdates = {
                [`completedBetting/${playerUUID}`]: true
            };

            if (!hasOpeningBet) {
                const openingTarget = Math.min(Math.max(pendingRaiseTarget, OPENING_BET_MIN), myChips);
                if (openingTarget <= 0) {
                    showToast('Invalid opening bet amount!');
                    return;
                }

                const newPot = (Number(state.pot) || 0) + openingTarget;
                const remainingChips = Math.max(0, myChips - openingTarget);

                playerChips[playerUUID] = remainingChips;
                currentPot = newPot;
                currentBet = openingTarget;
                firstPlayerBet = openingTarget;
                lastRaiseSize = openingTarget;

                updates[`players/${playerUUID}/chips`] = remainingChips;
                stateUpdates.pot = newPot;
                stateUpdates.currentBet = openingTarget;
                stateUpdates.firstPlayerBet = openingTarget;
                stateUpdates.lastRaiseSize = openingTarget;
                stateUpdates.bettingStarter = playerUUID;
                stateUpdates.lastAggressor = playerUUID;
                stateUpdates[`playerBets/${playerUUID}`] = openingTarget;
                stateUpdates[`allIn/${playerUUID}`] = remainingChips === 0;

                bettingStarted = true;
                bettingStarter = playerUUID;

                await db.ref(`lobbies/${lobbyId}`).update(updates);
                await updateGameSpecificState(GAME_TYPE, stateUpdates, lobbyId);
                disableBettingControls();
                showToast(`Opened betting at ${openingTarget} chips!`);
                checkBettingPhaseComplete();
                return;
            }

            const callAmount = Math.max(0, tableBet - myContribution);
            const paidAmount = Math.min(callAmount, myChips);
            const newContribution = myContribution + paidAmount;
            const remainingChips = Math.max(0, myChips - paidAmount);
            const newPot = (Number(state.pot) || 0) + paidAmount;

            playerChips[playerUUID] = remainingChips;
            currentPot = newPot;

            updates[`players/${playerUUID}/chips`] = remainingChips;
            stateUpdates.pot = newPot;
            stateUpdates[`playerBets/${playerUUID}`] = newContribution;
            stateUpdates[`allIn/${playerUUID}`] = remainingChips === 0;

            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, stateUpdates, lobbyId);

            disableBettingControls();
            if (callAmount === 0) {
                showToast('Check.');
            } else if (paidAmount < callAmount) {
                showToast(`Called all-in with ${paidAmount} chips.`);
            } else {
                showToast(`Called ${paidAmount} chips!`);
            }

            checkBettingPhaseComplete();
        }

        async function raiseBet() {
            if (!lobbyId || !playerUUID) return;

            const stateSnapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
            const state = stateSnapshot.val() || {};
            if (state.status !== 'betting' || state.currentTurn !== playerUUID) return;
            if (!state.bettingStarter || (Number(state.currentBet) || 0) <= 0) {
                showToast('Raise is available after opening bet.');
                return;
            }

            const myChips = getMyChipCount();
            const myContribution = getPlayerContribution(state, playerUUID);
            const tableBet = Number(state.currentBet) || 0;
            const minimumRaiseTarget = getMinimumRaiseTarget(state);
            const maxTarget = myContribution + myChips;

            if (maxTarget < minimumRaiseTarget) {
                showToast('Not enough chips to make a legal raise.');
                return;
            }

            const raiseTarget = Math.min(Math.max(pendingRaiseTarget, minimumRaiseTarget), maxTarget);
            if (raiseTarget <= tableBet) {
                showToast('Raise target must be above current bet.');
                return;
            }

            const raiseAmount = raiseTarget - myContribution;
            const raiseSize = raiseTarget - tableBet;
            const remainingChips = myChips - raiseAmount;
            const newPot = (Number(state.pot) || 0) + raiseAmount;
            const updates = {
                [`players/${playerUUID}/chips`]: remainingChips
            };
            const stateUpdates = {
                pot: newPot,
                currentBet: raiseTarget,
                lastRaiseSize: raiseSize,
                lastAggressor: playerUUID,
                [`playerBets/${playerUUID}`]: raiseTarget,
                [`completedBetting/${playerUUID}`]: true,
                [`allIn/${playerUUID}`]: remainingChips === 0
            };

            const turnOrder = state.turnOrder || [];
            const folded = state.folded || {};
            const allInMap = state.allIn || {};
            turnOrder.forEach(pid => {
                if (pid === playerUUID) return;
                if (folded[pid]) return;
                if (allInMap[pid]) return;
                stateUpdates[`completedBetting/${pid}`] = false;
            });

            playerChips[playerUUID] = remainingChips;
            currentPot = newPot;
            currentBet = raiseTarget;
            firstPlayerBet = state.firstPlayerBet || tableBet;
            lastRaiseSize = raiseSize;

            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, stateUpdates, lobbyId);

            disableBettingControls();
            showToast(`Raised to ${raiseTarget} chips!`);

            checkBettingPhaseComplete();
        }

        async function goAllIn() {
            if (!lobbyId || !playerUUID) return;

            const stateSnapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
            const state = stateSnapshot.val() || {};
            if (state.status !== 'betting' || state.currentTurn !== playerUUID) return;

            const myChips = getMyChipCount();
            if (myChips <= 0) {
                showToast('No chips to go all in!');
                return;
            }

            const myContribution = getPlayerContribution(state, playerUUID);
            const allInAmount = myChips;
            const totalContribution = myContribution + allInAmount;
            const tableBet = Number(state.currentBet) || 0;
            const hasOpeningBet = !!state.bettingStarter && tableBet > 0;
            const minRaiseSize = Math.max(Number(state.lastRaiseSize) || OPENING_BET_MIN, 1);
            const allInIncrease = Math.max(0, totalContribution - tableBet);
            const isFullRaise = allInIncrease >= minRaiseSize;

            currentPot = (Number(state.pot) || 0) + allInAmount;
            playerChips[playerUUID] = 0;

            const updates = {
                [`players/${playerUUID}/chips`]: 0
            };

            const stateUpdates = {
                pot: currentPot,
                [`completedBetting/${playerUUID}`]: true,
                [`playerBets/${playerUUID}`]: totalContribution,
                [`allIn/${playerUUID}`]: true
            };

            if (!hasOpeningBet) {
                stateUpdates.currentBet = totalContribution;
                stateUpdates.bettingStarter = playerUUID;
                stateUpdates.firstPlayerBet = totalContribution;
                stateUpdates.lastRaiseSize = totalContribution;
                stateUpdates.lastAggressor = playerUUID;
                firstPlayerBet = totalContribution;
                currentBet = totalContribution;
                lastRaiseSize = totalContribution;
                bettingStarted = true;
                bettingStarter = playerUUID;
            } else if (totalContribution > tableBet && isFullRaise) {
                stateUpdates.currentBet = totalContribution;
                stateUpdates.lastRaiseSize = allInIncrease;
                stateUpdates.lastAggressor = playerUUID;

                const turnOrder = state.turnOrder || [];
                const folded = state.folded || {};
                const allInMap = state.allIn || {};
                turnOrder.forEach(pid => {
                    if (pid === playerUUID) return;
                    if (folded[pid]) return;
                    if (allInMap[pid]) return;
                    stateUpdates[`completedBetting/${pid}`] = false;
                });

                currentBet = totalContribution;
                lastRaiseSize = allInIncrease;
            }

            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, stateUpdates, lobbyId);

            disableBettingControls();
            if (hasOpeningBet && totalContribution > tableBet && !isFullRaise) {
                showToast(`All in with ${allInAmount} chips (short all-in, no reopen).`);
            } else if (hasOpeningBet && totalContribution > tableBet) {
                showToast(`All in raise to ${totalContribution} chips!`);
            } else {
                showToast(`All in with ${allInAmount} chips!`);
            }

            checkBettingPhaseComplete();
        }

        async function fold() {
            hasFolded = true;
            
            await updateGameSpecificState(GAME_TYPE, {
                [`folded/${playerUUID}`]: true,
                [`completedBetting/${playerUUID}`]: true,
                [`completedRolling/${playerUUID}`]: true
            }, lobbyId);
            
            // Update local state immediately to reflect fold
            if (!currentMatchState.folded) currentMatchState.folded = {};
            if (!currentMatchState.completedBetting) currentMatchState.completedBetting = {};
            if (!currentMatchState.completedRolling) currentMatchState.completedRolling = {};
            currentMatchState.folded[playerUUID] = true;
            currentMatchState.completedBetting[playerUUID] = true;
            currentMatchState.completedRolling[playerUUID] = true;
            
            disableBettingControls();
            disableControls();
            showToast('You folded!');
            
            checkBettingPhaseComplete();
        }

        async function checkBettingPhaseComplete() {
            if (!isHostClient()) return;
            if (isBettingCheckInProgress) return;
            
            isBettingCheckInProgress = true;
            
            try {
                const snapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
                const state = snapshot.val();
                
                if (!state) {
                    console.log('No match state found');
                    return;
                }
                
                const turnOrder = state.turnOrder || [];
                const completedBetting = state.completedBetting || {};
                const folded = state.folded || {};
                const allInMap = state.allIn || {};
                const hasOpeningBet = !!state.bettingStarter && (Number(state.currentBet) || 0) > 0;

                const activePlayers = turnOrder.filter(pid => !folded[pid]);
                const playersSnapshot = await db.ref(`lobbies/${lobbyId}/players`).once('value');
                const playersData = playersSnapshot.val() || {};

                activePlayers.forEach(pid => {
                    if (allInMap[pid]) return;
                    const chips = Number(playersData[pid]?.chips);
                    if (Number.isFinite(chips) && chips <= 0) {
                        allInMap[pid] = true;
                    }
                });

                const actionRequiredPlayers = activePlayers.filter(pid => !allInMap[pid]);
                const allDone = actionRequiredPlayers.every(pid => completedBetting[pid]);
                
                console.log('Checking betting phase: allDone=', allDone, 'completedBetting=', completedBetting);
                
                if (allDone) {
                    // Move to rolling phase
                    console.log('Betting complete! Active players:', activePlayers);
                    
                    if (activePlayers.length === 1) {
                        // Only one player left, they win
                        await handleSingleWinner(activePlayers[0]);
                    } else if (activePlayers.length === 0) {
                        const fallbackWinner = state.bettingStarter || turnOrder[0];
                        if (fallbackWinner) {
                            await handleSingleWinner(fallbackWinner);
                        }
                    } else {
                        // Start rolling phase with the player who bet first
                        const startPlayer = (state.bettingStarter && activePlayers.includes(state.bettingStarter))
                            ? state.bettingStarter
                            : activePlayers[0];
                        console.log('Starting playing phase with player:', startPlayer);
                        
                        // Update local state immediately
                        currentMatchState.status = 'playing';
                        currentMatchState.currentTurn = startPlayer;
                        bettingStarted = false;
                        playerTurnComplete = false; // Reset for new phase
                        
                        // Update UI immediately
                        handleTurnLogic();
                        updateGameStatus();
                        
                        // Persist to Firebase
                        await updateGameSpecificState(GAME_TYPE, {
                            status: 'playing',
                            currentTurn: startPlayer,
                            spectatorView: buildInitialSpectatorView(startPlayer),
                            lastAction: {
                                type: 'turn_start',
                                playerId: startPlayer,
                                playerName: getPlayerDisplayName(startPlayer),
                                rollsLeft: 2,
                                updatedAt: Date.now()
                            }
                        }, lobbyId);
                    }
                } else {
                    // Advance to next player who has not completed betting
                    if (turnOrder.length === 0) return;
                    const currentIndex = turnOrder.indexOf(state.currentTurn);
                    const startIndex = currentIndex >= 0 ? currentIndex : -1;
                    let nextIndex = startIndex;
                    let nextPlayer = null;
                    
                    for (let i = 0; i < turnOrder.length; i++) {
                        nextIndex = (nextIndex + 1) % turnOrder.length;
                        const candidate = turnOrder[nextIndex];
                        if (folded[candidate] || allInMap[candidate]) continue;
                        const isCandidateBot = !!lobbyPlayers[candidate]?.isBot;
                        if (!completedBetting[candidate] && (hasOpeningBet || !isCandidateBot)) {
                            nextPlayer = candidate;
                            break;
                        }
                    }

                    if (!nextPlayer) {
                        for (let i = 0; i < turnOrder.length; i++) {
                            nextIndex = (nextIndex + 1) % turnOrder.length;
                            const candidate = turnOrder[nextIndex];
                            if (folded[candidate] || allInMap[candidate]) continue;
                            if (!completedBetting[candidate]) {
                                nextPlayer = candidate;
                                break;
                            }
                        }
                    }
                    
                    if (nextPlayer && nextPlayer !== state.currentTurn) {
                        console.log('Advancing to next bettor:', nextPlayer);
                        
                        // Update local state immediately
                        currentMatchState.currentTurn = nextPlayer;
                        
                        // Update UI immediately
                        handleTurnLogic();
                        updateGameStatus();
                        
                        // Persist to Firebase
                        await updateGameSpecificState(GAME_TYPE, {
                            currentTurn: nextPlayer
                        }, lobbyId);
                    }
                }
            } finally {
                isBettingCheckInProgress = false;
            }
        }

        async function handleSingleWinner(winnerId) {
            if (!lobbyId || !db || !winnerId) return;

            const lockRef = db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}/finishLocked`);
            const lockResult = await lockRef.transaction(current => {
                if (current) return;
                return true;
            });

            if (!lockResult.committed) {
                console.log('Single-winner finish skipped: finishLocked already set');
                return;
            }

            try {
                const [stateSnap, playersSnap] = await Promise.all([
                    db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value'),
                    db.ref(`lobbies/${lobbyId}/players`).once('value')
                ]);

                const state = stateSnap.val() || {};
                const playersData = playersSnap.val() || {};
                const playerBets = state.playerBets || {};
                const computedPot = Object.values(playerBets)
                    .reduce((sum, amount) => sum + (Number(amount) || 0), 0);
                const pot = computedPot > 0 ? computedPot : (Number(state.pot) || 0);
                const turnOrder = (state.turnOrder && state.turnOrder.length)
                    ? state.turnOrder
                    : Object.keys(playersData);
                const validWinnerId = playersData[winnerId] ? winnerId : turnOrder[0];

                if (!validWinnerId) {
                    await lockRef.set(false);
                    return;
                }

                const baseChips = Number(playersData[validWinnerId]?.chips) || 0;
                const winnerChips = baseChips + pot;
                const winnerBet = Number(playerBets[validWinnerId]) || 0;

                const updates = {
                    [`players/${validWinnerId}/chips`]: winnerChips,
                    [`players/${validWinnerId}/totalWins`]: (playersData[validWinnerId]?.totalWins || 0) + 1
                };

                await db.ref(`lobbies/${lobbyId}`).update(updates);

                const rankings = turnOrder.map((playerId, index) => {
                    const betAmount = Number(playerBets[playerId]) || 0;
                    const winnings = playerId === validWinnerId ? pot : 0;
                    return {
                        playerId,
                        playerName: lobbyPlayers[playerId]?.name || playersData[playerId]?.name || 'Player',
                        hand: playerId === validWinnerId ? 'Last Active Player' : 'Folded / Eliminated',
                        score: playerId === validWinnerId ? 0 : 'FOLDED',
                        winnings,
                        betAmount,
                        netGain: winnings - betAmount,
                        rank: playerId === validWinnerId ? 1 : Math.max(2, index + 1),
                        isWinner: playerId === validWinnerId
                    };
                });

                const nextRoundReady = {};
                Object.entries(playersData).forEach(([pid, player]) => {
                    const projectedChips = pid === validWinnerId ? winnerChips : getPlayerChipsValue(player);
                    nextRoundReady[pid] = !!player.isBot || willPlayerSitOutNextRound({ ...player, chips: projectedChips });
                });

                await updateGameSpecificState(GAME_TYPE, {
                    gameOver: true,
                    winners: [validWinnerId],
                    winner: validWinnerId,
                    rankings,
                    status: 'finished',
                    pot,
                    nextRoundReady,
                    spectatorView: null,
                    lastAction: null
                }, lobbyId);
            } catch (error) {
                console.error('handleSingleWinner failed:', error);
                await lockRef.set(false);
            }
        }

        // ==============================
        // ROLLING LOGIC
        // ==============================
        function enableRollingControls() {
            // Hide betting section
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'none';
            }
            
            resetTurn();
            document.getElementById('roll-btn').disabled = false;
            document.getElementById('end-turn-btn').disabled = true;
        }

        function disableRollingControls() {
            document.getElementById('roll-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = true;
        }

        function renderDice() {
            const container = document.getElementById('dice-container');
            container.innerHTML = '';

            const isMyActiveRollingTurn = !!currentMatchState
                && currentMatchState.status === 'playing'
                && currentMatchState.currentTurn === playerUUID
                && !hasFolded
                && !playerTurnComplete;

            dice.forEach((value, index) => {
                const dieEl = document.createElement('div');
                const canToggleHold = isMyActiveRollingTurn && rollsLeft < 2 && rollsLeft > 0 && value !== 0;
                const isDisabled = !canToggleHold;
                dieEl.className = `die ${heldDice[index] ? 'held' : ''} ${isDisabled ? 'disabled' : ''}`;
                dieEl.textContent = value || '?';
                dieEl.onclick = () => {
                    if (!canToggleHold) return;
                    toggleHold(index);
                };
                container.appendChild(dieEl);
            });
        }

        function toggleHold(index) {
            if (rollsLeft >= 2 || rollsLeft <= 0 || dice[index] === 0) return;
            if (currentMatchState.currentTurn !== playerUUID || hasFolded) return;
            
            heldDice[index] = !heldDice[index];
            renderDice();
            syncSpectatorView('hold_toggle');
        }

        async function rollDice() {
            if (rollsLeft === 0) return;
            if (currentMatchState.currentTurn !== playerUUID || hasFolded) return;

            rollsLeft--;
            document.getElementById('rolls-left').textContent = rollsLeft;

            dice = dice.map((val, i) => heldDice[i] ? val : Math.floor(Math.random() * 6) + 1);
            
            renderDice();
            evaluateHand();

            await syncSpectatorView('roll');

            if (rollsLeft === 0) {
                document.getElementById('roll-btn').disabled = true;
                document.getElementById('end-turn-btn').disabled = false;
            }
        }

        function evaluateHand() {
            // Count occurrences of each die value
            const counts = {};
            dice.forEach(d => {
                counts[d] = (counts[d] || 0) + 1;
            });
            
            const values = Object.values(counts).sort((a, b) => b - a);
            const uniqueValues = Object.keys(counts).map(Number).sort((a, b) => a - b);
            
            let handName = '';
            let rank = 0;
            
            // Check for hands (highest to lowest)
            if (values[0] === 5) {
                handName = 'üåü FIVE OF A KIND!';
                rank = 7;
            } else if (values[0] === 4) {
                handName = 'üíé FOUR OF A KIND!';
                rank = 6;
            } else if (values[0] === 3 && values[1] === 2) {
                handName = 'üè† FULL HOUSE!';
                rank = 5;
            } else if (uniqueValues.length === 5 && 
                       (uniqueValues.join('') === '12345' || uniqueValues.join('') === '23456')) {
                handName = 'üìä STRAIGHT!';
                rank = 4;
            } else if (values[0] === 3) {
                handName = 'üéØ THREE OF A KIND';
                rank = 3;
            } else if (values[0] === 2 && values[1] === 2) {
                handName = 'üë• TWO PAIR';
                rank = 2;
            } else if (values[0] === 2) {
                handName = 'üé≤ ONE PAIR';
                rank = 1;
            } else {
                handName = 'High Card';
                rank = 0;
            }
            
            currentScore = rank;
            document.getElementById('current-score').textContent = rank;
            document.getElementById('hand-result').textContent = handName;
        }

        // ==============================
        // TURN MANAGEMENT
        // ==============================
        async function endTurn() {
            if (currentMatchState.currentTurn !== playerUUID || hasFolded) return;

            await db.ref(`lobbies/${lobbyId}/players/${playerUUID}/score`).set(currentScore);
            await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}/completedRolling/${playerUUID}`).set(true);
            await syncSpectatorView('end_turn');
            
            // Mark this turn as complete locally to prevent re-enabling controls before turn advances
            playerTurnComplete = true;
            
            disableControls();
            showToast('Turn ended!');
            
            checkRollingPhaseComplete();
        }

        async function checkRollingPhaseComplete() {
            if (!isHostClient()) return;
            if (isRollingCheckInProgress) return;
            
            isRollingCheckInProgress = true;
            
            try {
                const snapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
                const state = snapshot.val();
                
                const turnOrder = state.turnOrder || [];
                const completedRolling = state.completedRolling || {};
                const folded = state.folded || {};

                if (state.gameOver || state.status === 'finished') {
                    console.log('Game already finished; skipping rolling checks');
                    return;
                }

                if (!state.currentTurn) {
                    console.log('No current turn set for rolling phase');
                    return;
                }

                const activePlayers = turnOrder.filter(pid => !folded[pid]);
                const allDone = activePlayers.every(pid => completedRolling[pid]);
                
                console.log('Checking rolling phase: allDone=', allDone, 'turnOrder=', turnOrder.map(p => lobbyPlayers[p]?.name), 'completedRolling=', Object.keys(completedRolling).map(k => lobbyPlayers[k]?.name));
                
                if (allDone) {
                    console.log('All players rolled! Finishing game...');
                    await finishGame();
                } else {
                    if (!completedRolling[state.currentTurn]) {
                        console.log('Current player has not completed rolling yet:', state.currentTurn);
                        return;
                    }
                    // Move to next active player
                    const currentIndex = turnOrder.indexOf(state.currentTurn);
                    console.log('Current player index:', currentIndex, 'current player:', lobbyPlayers[state.currentTurn]?.name);
                    let nextIndex = (currentIndex + 1) % turnOrder.length;
                    
                    while (folded[turnOrder[nextIndex]]) {
                        nextIndex = (nextIndex + 1) % turnOrder.length;
                    }
                    
                    console.log('Advancing to next roller index:', nextIndex, 'player:', lobbyPlayers[turnOrder[nextIndex]]?.name);
                    const nextPlayer = turnOrder[nextIndex];
                    await updateGameSpecificState(GAME_TYPE, {
                        currentTurn: nextPlayer,
                        spectatorView: buildInitialSpectatorView(nextPlayer),
                        lastAction: {
                            type: 'turn_start',
                            playerId: nextPlayer,
                            playerName: getPlayerDisplayName(nextPlayer),
                            rollsLeft: 2,
                            updatedAt: Date.now()
                        }
                    }, lobbyId);
                    console.log('Firebase updated with new currentTurn');
                }
            } finally {
                isRollingCheckInProgress = false;
            }
        }

        function resetTurn() {
            rollsLeft = 2;
            dice = [0, 0, 0, 0, 0];
            heldDice = [false, false, false, false, false];
            currentScore = 0;
            
            document.getElementById('rolls-left').textContent = rollsLeft;
            document.getElementById('current-score').textContent = currentScore;
            document.getElementById('hand-result').textContent = 'Roll to see your hand!';
            
            renderDice();
        }

        function enableControls() {
            document.getElementById('roll-btn').disabled = false;
            document.getElementById('end-turn-btn').disabled = true;
        }

        function disableControls() {
            // Hide betting section
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'none';
            }
            
            document.getElementById('roll-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = true;
        }



        function isHostClient() {
            // First real (non-bot) player is the host
            const realPlayers = Object.entries(lobbyPlayers)
                .filter(([id, player]) => !player.isBot)
                .sort((a, b) => {
                    const joinedAtDiff = (a[1].joinedAt || 0) - (b[1].joinedAt || 0);
                    if (joinedAtDiff !== 0) return joinedAtDiff;
                    return a[0].localeCompare(b[0]);
                });
            
            return realPlayers.length > 0 && realPlayers[0][0] === playerUUID;
        }

        function getHandName(score) {
            const handNames = {
                7: 'Five of a Kind',
                6: 'Four of a Kind',
                5: 'Full House',
                4: 'Straight',
                3: 'Three of a Kind',
                2: 'Two Pair',
                1: 'One Pair',
                0: 'High Card'
            };
            return handNames[score] || null;
        }

        async function updateMatchState(updates) {
            if (!lobbyId || !db) return;
            await updateGameSpecificState(GAME_TYPE, updates, lobbyId);
        }

        // ==============================
        // BOT LOGIC
        // ==============================
        async function runBotBet(botId) {
            if (!lobbyId || !botId) return;

            const stateSnapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
            const state = stateSnapshot.val() || {};

            if (state.status !== 'betting' || state.currentTurn !== botId) return;
            if ((state.completedBetting || {})[botId]) return;

            const isFirstBet = !state.bettingStarter;
            if (isFirstBet) {
                console.log('Bot turn reached before opening human bet; advancing turn.');
                await checkBettingPhaseComplete();
                return;
            }

            const playersSnapshot = await db.ref(`lobbies/${lobbyId}/players`).once('value');
            const playersData = playersSnapshot.val() || {};

            const botChips = Number(playersData[botId]?.chips);
            const fallbackBotChips = Number(playerChips[botId]);
            const safeBotChips = Number.isFinite(botChips) ? botChips : (Number.isFinite(fallbackBotChips) ? fallbackBotChips : STARTING_CHIPS);
            const tableBet = Number(state.currentBet) || Number(firstPlayerBet) || 0;
            const statePot = Number(state.pot) || 0;
            const botContribution = Number((state.playerBets || {})[botId]) || 0;
            const callAmount = Math.max(0, tableBet - botContribution);
            const minimumRaiseSize = Math.max(Number(state.lastRaiseSize) || OPENING_BET_MIN, 1);
            const minimumRaiseTarget = tableBet + minimumRaiseSize;
            const botMaxTarget = botContribution + safeBotChips;
            const canRaise = botMaxTarget >= minimumRaiseTarget;
            const shouldRaise = canRaise && Math.random() < 0.28;
            
            if (callAmount <= 0 && !shouldRaise) {
                await updateGameSpecificState(GAME_TYPE, {
                    [`completedBetting/${botId}`]: true
                }, lobbyId);
                showToast(`${lobbyPlayers[botId].name} checks.`);
            } else if (shouldRaise) {
                const raiseCap = Math.min(botMaxTarget, minimumRaiseTarget + minimumRaiseSize);
                const raiseTarget = Math.max(minimumRaiseTarget, raiseCap);
                const chipsSpent = raiseTarget - botContribution;
                const chipsLeft = safeBotChips - chipsSpent;
                const raiseSize = raiseTarget - tableBet;

                playerChips[botId] = chipsLeft;
                currentPot = statePot + chipsSpent;

                const stateUpdates = {
                    pot: currentPot,
                    currentBet: raiseTarget,
                    lastRaiseSize: raiseSize,
                    lastAggressor: botId,
                    [`completedBetting/${botId}`]: true,
                    [`playerBets/${botId}`]: raiseTarget,
                    [`allIn/${botId}`]: chipsLeft === 0
                };

                const turnOrder = state.turnOrder || [];
                const folded = state.folded || {};
                const allInMap = state.allIn || {};
                turnOrder.forEach(pid => {
                    if (pid === botId) return;
                    if (folded[pid]) return;
                    if (allInMap[pid]) return;
                    stateUpdates[`completedBetting/${pid}`] = false;
                });

                await db.ref(`lobbies/${lobbyId}/players/${botId}/chips`).set(chipsLeft);
                await updateGameSpecificState(GAME_TYPE, stateUpdates, lobbyId);
                showToast(`${lobbyPlayers[botId].name} raised to ${raiseTarget}!`);
            } else if (safeBotChips <= 0) {
                // Bot has no chips
                await updateGameSpecificState(GAME_TYPE, {
                    [`folded/${botId}`]: true,
                    [`completedBetting/${botId}`]: true,
                    [`completedRolling/${botId}`]: true
                }, lobbyId);
                showToast(`${lobbyPlayers[botId].name} has no chips!`);
            } else if (safeBotChips < callAmount) {
                // Bot goes all-in if short on chips
                playerChips[botId] = 0;
                currentPot = statePot + safeBotChips;
                
                await db.ref(`lobbies/${lobbyId}/players/${botId}/chips`).set(0);
                await updateGameSpecificState(GAME_TYPE, {
                    pot: currentPot,
                    [`completedBetting/${botId}`]: true,
                    [`playerBets/${botId}`]: botContribution + safeBotChips,
                    [`allIn/${botId}`]: true
                }, lobbyId);
                
                showToast(`${lobbyPlayers[botId].name} went all-in with ${safeBotChips} chips!`);
            } else {
                // Bot calls the bet
                playerChips[botId] = safeBotChips - callAmount;
                currentPot = statePot + callAmount;
                
                await db.ref(`lobbies/${lobbyId}/players/${botId}/chips`).set(playerChips[botId]);
                await updateGameSpecificState(GAME_TYPE, {
                    pot: currentPot,
                    [`completedBetting/${botId}`]: true,
                    [`playerBets/${botId}`]: botContribution + callAmount,
                    [`allIn/${botId}`]: playerChips[botId] === 0
                }, lobbyId);
                
                showToast(`${lobbyPlayers[botId].name} called with ${callAmount} chips!`);
            }
            
            checkBettingPhaseComplete();
        }

        async function runBotRoll(botId) {
            if (!lobbyId || !botId) return;

            const stateSnapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
            const initialState = stateSnapshot.val() || {};
            if (initialState.status !== 'playing' || initialState.currentTurn !== botId) return;
            if ((initialState.completedRolling || {})[botId]) return;

            let botDice = [0, 0, 0, 0, 0];
            let botHeld = [false, false, false, false, false];
            let botScore = 0;

            await updateGameSpecificState(GAME_TYPE, {
                spectatorView: {
                    playerId: botId,
                    playerName: getPlayerDisplayName(botId),
                    dice: [...botDice],
                    heldDice: [...botHeld],
                    rollsLeft: 2,
                    score: botScore,
                    handName: 'Roll to see your hand!',
                    updatedAt: Date.now()
                },
                lastAction: {
                    type: 'turn_start',
                    playerId: botId,
                    playerName: getPlayerDisplayName(botId),
                    rollsLeft: 2,
                    updatedAt: Date.now()
                }
            }, lobbyId);

            await delay(BOT_TURN_START_DELAY_MS);
            
            for (let roll = 0; roll < 2; roll++) {
                const rollingStateSnapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
                const rollingState = rollingStateSnapshot.val() || {};
                if (rollingState.status !== 'playing' || rollingState.currentTurn !== botId) {
                    return;
                }

                botDice = botDice.map((val, i) => botHeld[i] ? val : Math.floor(Math.random() * 6) + 1);
                
                if (roll === 0) {
                    const counts = {};
                    botDice.forEach(d => counts[d] = (counts[d] || 0) + 1);
                    
                    botDice.forEach((val, i) => {
                        if (counts[val] >= 2) {
                            botHeld[i] = true;
                        }
                    });
                }

                botScore = calculateBotScore(botDice);

                await updateGameSpecificState(GAME_TYPE, {
                    spectatorView: {
                        playerId: botId,
                        playerName: getPlayerDisplayName(botId),
                        dice: [...botDice],
                        heldDice: [...botHeld],
                        rollsLeft: 1 - roll,
                        score: botScore,
                        handName: getHandName(botScore) || 'High Card',
                        updatedAt: Date.now()
                    },
                    lastAction: {
                        type: 'roll',
                        playerId: botId,
                        playerName: getPlayerDisplayName(botId),
                        rollsLeft: 1 - roll,
                        updatedAt: Date.now()
                    }
                }, lobbyId);

                await delay(BOT_ROLL_STEP_DELAY_MS);
            }
            
            await db.ref(`lobbies/${lobbyId}/players/${botId}/score`).set(botScore);
            await updateGameSpecificState(GAME_TYPE, {
                [`completedRolling/${botId}`]: true,
                lastAction: {
                    type: 'end_turn',
                    playerId: botId,
                    playerName: getPlayerDisplayName(botId),
                    rollsLeft: 0,
                    updatedAt: Date.now()
                }
            }, lobbyId);

            await delay(BOT_TURN_END_DELAY_MS);
            
            showToast(`${lobbyPlayers[botId].name} rolled! Score: ${botScore}`);
            
            checkRollingPhaseComplete();
        }

        function calculateBotScore(dice) {
            const counts = {};
            dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            
            const values = Object.values(counts).sort((a, b) => b - a);
            const uniqueValues = Object.keys(counts).map(Number).sort((a, b) => a - b);
            
            if (values[0] === 5) return 7;
            if (values[0] === 4) return 6;
            if (values[0] === 3 && values[1] === 2) return 5;
            if (uniqueValues.length === 5 && 
                (uniqueValues.join('') === '12345' || uniqueValues.join('') === '23456')) return 4;
            if (values[0] === 3) return 3;
            if (values[0] === 2 && values[1] === 2) return 2;
            if (values[0] === 2) return 1;
            return 0;
        }

        // ==============================
        // GAME END & SCOREBOARD
        // ==============================
        async function finishGame() {
            if (!lobbyId || !db) return;
            const lockRef = db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}/finishLocked`);
            const lockResult = await lockRef.transaction(current => {
                if (current) return;
                return true;
            });

            if (!lockResult.committed) {
                console.log('finishGame skipped: finishLocked already set');
                return;
            }

            try {
                const [gameStateSnapshot, playersSnapshot] = await Promise.all([
                    db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value'),
                    db.ref(`lobbies/${lobbyId}/players`).once('value')
                ]);

                const state = gameStateSnapshot.val() || {};
                const folded = state.folded || {};
                const playerBets = state.playerBets || {};
                const computedPot = Object.values(playerBets)
                    .reduce((sum, amount) => sum + (Number(amount) || 0), 0);
                const statePot = computedPot > 0 ? computedPot : (Number(state.pot) || 0);
                const playersData = playersSnapshot.val() || {};
                const turnOrder = (state.turnOrder && state.turnOrder.length)
                    ? state.turnOrder
                    : Object.keys(playersData);
                const playerScores = {};
                let highestScore = -1;
                
                // Get hand names for display
                const handNames = {
                    7: 'Five of a Kind',
                    6: 'Four of a Kind',
                    5: 'Full House',
                    4: 'Straight',
                    3: 'Three of a Kind',
                    2: 'Two Pair',
                    1: 'One Pair',
                    0: 'High Card',
                    '-1': 'FOLDED'
                };
                
                turnOrder.forEach((playerId) => {
                    const score = folded[playerId] ? -1 : (playersData[playerId]?.score ?? 0);
                    playerScores[playerId] = score;
                    
                    if (score > highestScore) {
                        highestScore = score;
                    }
                });
                
                // Find all winners (could be multiple in case of tie)
                let winnerIds = Object.entries(playerScores)
                    .filter(([_, score]) => score === highestScore && score >= 0)
                    .map(([playerId, _]) => playerId);

                if (winnerIds.length === 0 && turnOrder.length > 0) {
                    const fallbackWinner = state.bettingStarter || turnOrder[0];
                    winnerIds = fallbackWinner ? [fallbackWinner] : [turnOrder[0]];
                    highestScore = playerScores[winnerIds[0]] ?? 0;
                }

                winnerIds.sort((a, b) => turnOrder.indexOf(a) - turnOrder.indexOf(b));
                
                console.log('Winners:', winnerIds, 'Score:', highestScore);
                
                // Split pot evenly among winners
                const winnerCount = Math.max(1, winnerIds.length);
                const potPerWinner = Math.floor(statePot / winnerCount);
                const potRemainder = statePot % winnerCount;
                
                const chipUpdates = {};
                
                // Award pot to winners and increment wins
                winnerIds.forEach((winnerId, index) => {
                    const chipGain = potPerWinner + (index === 0 ? potRemainder : 0);
                    const baseChips = Number(playersData[winnerId]?.chips) || 0;
                    const winnerChips = baseChips + chipGain;
                    chipUpdates[`players/${winnerId}/chips`] = winnerChips;
                    chipUpdates[`players/${winnerId}/totalWins`] = (playersData[winnerId]?.totalWins || 0) + 1;
                });

                turnOrder.forEach((pid) => {
                    if (!("players/" + pid + "/chips" in chipUpdates)) {
                        chipUpdates[`players/${pid}/chips`] = Number(playersData[pid]?.chips) || 0;
                    }
                    if (!("players/" + pid + "/totalWins" in chipUpdates)) {
                        chipUpdates[`players/${pid}/totalWins`] = playersData[pid]?.totalWins || 0;
                    }
                });
                
                // Calculate net gain/loss for each player
                const rankings = Object.entries(playerScores)
                    .sort((a, b) => {
                        if (a[1] === b[1]) return 0;
                        if (a[1] === -1) return 1;
                        if (b[1] === -1) return -1;
                        return b[1] - a[1];
                    })
                    .map(([playerId, score], index) => {
                        const betAmount = Number(playerBets[playerId]) || 0;
                        const handName = handNames[score] || 'Unknown';
                        const isWinner = winnerIds.includes(playerId);
                        const winnings = isWinner ? Math.floor(statePot / winnerCount) + (winnerIds.indexOf(playerId) === 0 ? statePot % winnerCount : 0) : 0;
                        const netGain = winnings - betAmount;
                        
                        return {
                            playerId,
                            playerName: lobbyPlayers[playerId]?.name || playersData[playerId]?.name || 'Player',
                            hand: handName,
                            score: score === -1 ? 'FOLDED' : score,
                            winnings: winnings,
                            betAmount: betAmount,
                            netGain: netGain,
                            rank: index + 1,
                            isWinner: isWinner
                        };
                    });
                
                await db.ref(`lobbies/${lobbyId}`).update(chipUpdates);
                currentPot = statePot;

                const nextRoundReady = {};
                Object.entries(playersData).forEach(([pid, player]) => {
                    const projectedChips = Number(chipUpdates[`players/${pid}/chips`]);
                    const effectiveChips = Number.isFinite(projectedChips) ? projectedChips : getPlayerChipsValue(player);
                    nextRoundReady[pid] = !!player.isBot || willPlayerSitOutNextRound({ ...player, chips: effectiveChips });
                });
                
                // Update game state
                await updateGameSpecificState(GAME_TYPE, {
                    gameOver: true,
                    winner: winnerIds[0] || null,
                    winners: winnerIds,
                    rankings: rankings,
                    status: 'finished',
                    nextRoundReady: nextRoundReady,
                    spectatorView: null,
                    lastAction: null
                }, lobbyId);
                
                showScoreboard(rankings, winnerIds[0]);
            } catch (error) {
                console.error('finishGame failed:', error);
                await lockRef.set(false);
            }
        }

        async function markNextRoundReady() {
            if (!lobbyId || !playerUUID) return;
            if (!currentMatchState || currentMatchState.status !== 'finished') {
                showToast('Round not finished yet.');
                return;
            }

            if (willPlayerSitOutNextRound(lobbyPlayers[playerUUID])) {
                showToast('You are sitting out next round.');
                const readyBtn = document.getElementById('scoreboard-ready-btn');
                if (readyBtn) readyBtn.disabled = true;
                return;
            }

            try {
                await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}/nextRoundReady/${playerUUID}`).set(true);
                showToast('Ready for next round!');

                if (isHostClient()) {
                    setTimeout(checkAllNextRoundReady, 300);
                }
            } catch (error) {
                console.error('Error setting next round ready:', error);
                showToast('Error setting ready');
            }
        }

        async function checkAllNextRoundReady() {
            if (!isHostClient()) return;
            if (isNextRoundCheckInProgress) return;
            if (!currentMatchState || currentMatchState.status !== 'finished') return;

            isNextRoundCheckInProgress = true;

            try {
                const [stateSnapshot, playersSnapshot] = await Promise.all([
                    db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value'),
                    db.ref(`lobbies/${lobbyId}/players`).once('value')
                ]);
                const state = stateSnapshot.val();
                const playersData = playersSnapshot.val() || lobbyPlayers;

                if (!state || state.status !== 'finished') return;

                const nextRoundReady = state.nextRoundReady || {};
                const allHumansReady = Object.entries(playersData).every(([playerId, player]) => {
                    if (player.isBot) return true;
                    if (willPlayerSitOutNextRound(player)) return true;
                    return nextRoundReady[playerId] === true;
                });

                if (allHumansReady) {
                    await playAgain();
                }
            } finally {
                isNextRoundCheckInProgress = false;
            }
        }

        function updateScoreboardReadyStatus() {
            const statusEl = document.getElementById('scoreboard-ready-status');
            const readyBtn = document.getElementById('scoreboard-ready-btn');

            if (!statusEl || !currentMatchState || currentMatchState.status !== 'finished') {
                if (readyBtn) readyBtn.disabled = true;
                return;
            }

            const nextRoundReady = currentMatchState.nextRoundReady || {};
            const notReadyPlayers = [];
            const sitOutNextRoundPlayers = [];

            Object.entries(lobbyPlayers).forEach(([playerId, player]) => {
                if (player.isBot) return;
                if (willPlayerSitOutNextRound(player)) {
                    const sitRounds = getSitOutRoundsRemaining(player);
                    if (sitRounds > 0) {
                        sitOutNextRoundPlayers.push(`${player.name || `Player-${playerId.slice(0, 4)}`} (${sitRounds} left)`);
                    } else {
                        sitOutNextRoundPlayers.push(`${player.name || `Player-${playerId.slice(0, 4)}`} (bankrupt)`);
                    }
                    return;
                }
                if (!nextRoundReady[playerId]) {
                    notReadyPlayers.push(player.name || `Player-${playerId.slice(0, 4)}`);
                }
            });

            if (notReadyPlayers.length === 0) {
                const sitOutSuffix = sitOutNextRoundPlayers.length
                    ? `<br><span style="color: #aab7b8;">Sitting out next round: ${sitOutNextRoundPlayers.join(', ')}</span>`
                    : '';
                statusEl.innerHTML = `<span style="color: #27ae60;">All active players ready! Starting next round...</span>${sitOutSuffix}`;
            } else {
                const sitOutSuffix = sitOutNextRoundPlayers.length
                    ? `<br><span style="color: #aab7b8;">Sitting out next round: ${sitOutNextRoundPlayers.join(', ')}</span>`
                    : '';
                statusEl.innerHTML = `Waiting on: <strong>${notReadyPlayers.join(', ')}</strong>${sitOutSuffix}`;
            }

            const isReady = !!nextRoundReady[playerUUID];
            const iAmSittingOutNextRound = willPlayerSitOutNextRound(lobbyPlayers[playerUUID]);
            if (readyBtn) readyBtn.disabled = isReady || iAmSittingOutNextRound;
        }

        function showScoreboard(rankings, winnerPlayerId) {
            populateScoreboard(rankings, winnerPlayerId);
            document.getElementById('scoreboardModal').classList.add('active');
            updateScoreboardReadyStatus();
            scoreboardShown = true;
        }

        function populateScoreboard(rankings, winnerPlayerId) {
            const resultsContainer = document.getElementById('scoreboardResults');
            resultsContainer.innerHTML = '';
            
            rankings.forEach((entry) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'score-row-item';
                
                const rankDisplay = ['ü•á', 'ü•à', 'ü•â'][entry.rank - 1] || `#${entry.rank}`;
                const winnerBadge = entry.isWinner ? '<span class="winner-badge">üëë WINNER</span>' : '';
                
                // Show net gain/loss with color
                const netGainColor = entry.netGain >= 0 ? '#27ae60' : '#e74c3c';
                const netGainSign = entry.netGain >= 0 ? '+' : '';
                const netGainDisplay = `<div style="color: ${netGainColor}; font-size: 0.9rem; font-weight: bold;">Net: ${netGainSign}${entry.netGain} chips</div>`;
                
                const handDisplay = entry.score === 'FOLDED' ? `<div style="color: #999; font-style: italic;">Folded</div>` : `<div style="color: #ffd700;">Hand: ${entry.hand}</div>`;
                
                resultItem.innerHTML = `
                    <div style="display: flex; align-items: center; width: 100%; gap: 15px;">
                        <div style="font-size: 1.8rem; min-width: 50px;">${rankDisplay}</div>
                        <div style="flex: 1;">
                            <div style="font-size: 1.2rem; font-weight: bold;">${entry.playerName}</div>
                            ${handDisplay}
                            ${netGainDisplay}
                        </div>
                        ${winnerBadge}
                    </div>
                `;
                
                if (entry.isWinner) {
                    resultItem.classList.add('winner');
                }
                
                resultsContainer.appendChild(resultItem);
            });
        }

        async function returnToLobbyFromScoreboard() {
            document.getElementById('scoreboardModal').classList.remove('active');
            
            // Stop listening but keep player in lobby
            if (window.globalLobbyRef) {
                offLobbyUpdate(window.globalLobbyRef);
                window.globalLobbyRef = null;
            }
            
            // Mark player as back in lobby
            await updatePlayerStatus('inLobby', lobbyId);
            
            // Preserve lobby ID
            if (lobbyId) {
                window.currentLobbyId = lobbyId;
                sessionStorage.setItem('currentLobbyId', lobbyId);
            }
            
            // Redirect to lobby
            window.location.href = '../../lobby.html';
        }

        async function playAgain() {
            if (!isHostClient()) {
                showToast('Waiting for host to start the next round...');
                return;
            }

            document.getElementById('scoreboardModal').classList.remove('active');
            
            dice = [0, 0, 0, 0, 0];
            heldDice = [false, false, false, false, false];
            rollsLeft = 2;
            currentScore = 0;
            currentPot = 0;
            currentBet = 0;
            firstPlayerBet = 0;
            lastRaiseSize = 50;
            pendingRaiseTarget = 50;
            bettingStarted = false;
            bettingStarter = null;
            playerTurnComplete = false;
            scoreboardShown = false;
            gameStarted = false;
            hasFolded = false;
            gameInitialized = false; // Reset so ready-up shows again
            
            renderDice();
            
            const playersSnapshot = await db.ref(`lobbies/${lobbyId}/players`).once('value');
            const latestPlayers = playersSnapshot.val() || lobbyPlayers;

            // Reset all players - prepare for new round
            const { turnPlayers, playerStates, updates } = buildNextRoundSetup(latestPlayers);
            
            const nextMatchState = {
                status: 'waiting',
                turnOrder: turnPlayers,
                currentTurn: turnPlayers[0] || null,
                round: (currentMatchState.round || 1) + 1,
                pot: 0,
                currentBet: 0,
                lastRaiseSize: 50,
                playerBets: {},
                allIn: {},
                folded: {},
                completedBetting: {},
                completedRolling: {},
                playerStates: playerStates,
                nextRoundReady: {},
                spectatorView: null,
                lastAction: null,
                finishLocked: false,
                gameOver: false,
                winner: null,
                rankings: null
            };
            
            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, nextMatchState, lobbyId);
            
            showToast('New game started! Ready up to begin...');
        }

        // ==============================
        // UTILITY FUNCTIONS
        // ==============================
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        async function returnToLobby() {
            if (confirm('Are you sure you want to leave the game?')) {
                try {
                    // Stop listening to lobby updates
                    if (window.globalLobbyRef) {
                        offLobbyUpdate(window.globalLobbyRef);
                        window.globalLobbyRef = null;
                    }
                    
                    // Mark player as back in lobby
                    await updatePlayerStatus('inLobby', lobbyId);
                    
                    // Keep player in lobby and preserve current lobby ID
                    if (lobbyId) {
                        window.currentLobbyId = lobbyId;
                        sessionStorage.setItem('currentLobbyId', lobbyId);
                    }
                } catch (error) {
                    console.error('Error leaving lobby:', error);
                }
                // Allow a moment for cleanup before redirecting
                setTimeout(() => {
                    window.location.href = '../../lobby.html';
                }, 300);
            }
        }

        async function leaveLobby() {
            if (!db || !lobbyId || !playerUUID) {
                console.error('Missing required data for leaving lobby');
                return false;
            }
            
            try {
                // Remove player from lobby
                await db.ref(`lobbies/${lobbyId}/players/${playerUUID}`).remove();
                console.log('Left lobby:', lobbyId);
                window.currentLobbyId = null;
                sessionStorage.removeItem('currentLobbyId');
                return true;
            } catch (error) {
                console.error('Error leaving lobby:', error);
                return false;
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (window.globalLobbyRef) {
                offLobbyUpdate(window.globalLobbyRef);
            }
        });
    </script>
</body>
</html>
