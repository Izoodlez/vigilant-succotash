<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zood's Chess Room</title>
    <link rel="icon" href="../../assets/images/icons/ZoodsRoomFaviconTransparent.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --board-light: #ebecd0;
            --board-dark: #779556;
            --highlight-move: rgba(255, 255, 0, 0.5);
            --highlight-selected: rgba(186, 202, 43, 0.8);
            --highlight-last: rgba(246, 246, 105, 0.4);
            --highlight-check: radial-gradient(ellipse at center, rgba(255,0,0,0.8) 0%, rgba(255,0,0,0) 70%);
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            width: 100%;
            max-width: 600px;
            border: 4px solid #333;
            user-select: none;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }

        .square.light { background-color: var(--board-light); }
        .square.dark { background-color: var(--board-dark); }

        .square.selected { background-color: var(--highlight-selected) !important; }
        .square.last-move { background-color: var(--highlight-last); }
        .square.check { background: var(--highlight-check) !important; }

        .piece {
            width: 90%;
            height: 90%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), filter 0.2s ease;
            cursor: grab;
        }

        .piece:active { cursor: grabbing; }

        .piece:hover {
            transform: scale(1.15) translateY(-5px);
            filter: drop-shadow(0 10px 8px rgba(0,0,0,0.4));
        }

        .piece svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));
        }

        .move-dot {
            width: 25%;
            height: 25%;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 50%;
            position: absolute;
            z-index: 5;
        }

        .capture-ring {
            width: 85%;
            height: 85%;
            border: 5px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            position: absolute;
            z-index: 5;
        }

        .move-history {
            max-height: 250px;
            overflow-y: auto;
        }

        /* Custom Scrollbar */
        .move-history::-webkit-scrollbar { width: 6px; }
        .move-history::-webkit-scrollbar-track { background: transparent; }
        .move-history::-webkit-scrollbar-thumb { background: #444; border-radius: 10px; }

        @media (max-width: 640px) {
            .chess-container { flex-direction: column; }
        }
    </style>
</head>
<body class="bg-zinc-900 text-zinc-100 min-h-screen flex flex-col items-center p-4">

    <header class="mb-6 text-center">
        <h1 class="text-4xl font-bold text-green-500 mb-2">Zood's Chess</h1>
        <p class="text-zinc-400">Classic Strategy Game</p>
    </header>

    <main class="w-full max-w-6xl flex flex-col lg:flex-row gap-8 items-start justify-center">
        
        <!-- Game Column -->
        <div class="flex flex-col items-center w-full max-w-[600px]">
            <!-- Status Bar -->
            <div id="game-status" class="w-full bg-zinc-800 p-4 rounded-t-lg flex justify-between items-center border-b border-zinc-700">
                <div class="flex items-center gap-3">
                    <div id="turn-indicator" class="w-4 h-4 rounded-full bg-white shadow-[0_0_10px_rgba(255,255,255,0.5)]"></div>
                    <span id="status-text" class="font-semibold text-lg uppercase tracking-wider">White's Turn</span>
                </div>
                <button id="reset-btn" class="bg-zinc-700 hover:bg-zinc-600 px-4 py-1 rounded text-sm transition font-medium">Reset</button>
            </div>

            <!-- The Board -->
            <div id="board" class="chess-board shadow-2xl"></div>

            <!-- Captured Pieces -->
            <div class="w-full bg-zinc-800 p-4 rounded-b-lg mt-1 flex flex-col gap-2 border-t border-zinc-700">
                <div class="flex justify-between items-center text-[10px] uppercase text-zinc-500 font-black tracking-widest">
                    <span>Captured Pieces</span>
                </div>
                <div class="flex justify-between items-center">
                    <div id="captured-white" class="flex flex-wrap gap-1 min-h-[30px]"></div>
                    <div id="captured-black" class="flex flex-wrap gap-1 min-h-[30px]"></div>
                </div>
            </div>
        </div>

        <!-- Info Column -->
        <div class="w-full lg:w-80 flex flex-col gap-4">
            <div class="bg-zinc-800 p-5 rounded-lg border border-zinc-700 shadow-xl">
                <div class="flex justify-between items-center mb-4 border-b border-zinc-700 pb-2">
                    <h2 class="text-xl font-bold">History</h2>
                    <button id="pgn-btn" class="text-[10px] bg-green-600 hover:bg-green-500 text-white px-2 py-1 rounded font-bold uppercase transition">Export PGN</button>
                </div>
                <!-- Updated Grid Structure for Natural Layout -->
                <div id="move-log" class="move-history grid grid-cols-[40px_1fr_1fr] gap-x-2 gap-y-1 text-sm font-mono text-zinc-300 p-2">
                    <!-- Moves injected here -->
                </div>
            </div>

            <div class="bg-zinc-800 p-5 rounded-lg border border-zinc-700 shadow-xl">
                <h2 class="text-xl font-bold mb-2 text-green-500">How to Play</h2>
                <ul class="text-sm text-zinc-400 space-y-2 list-disc ml-4">
                    <li><strong>Objective:</strong> Checkmate the opponent's King.</li>
                    <li><strong>Movement:</strong> Click a piece to see valid moves (dots) and captures (rings).</li>
                    <li><strong>Check:</strong> If your King is in danger, you must move it to safety.</li>
                    <li><strong>Winning:</strong> The game ends when a King is in check and cannot escape (Checkmate).</li>
                </ul>
            </div>
        </div>
    </main>

    <footer class="mt-auto pt-8 pb-4 text-zinc-600 text-xs">
        &copy; 2024 izoodlez - Zood's Room Games
    </footer>

    <script>
        // --- Piece SVGs ---
        // Standard Cburnett style for better visuals
        const PIECES_SVG = {
            w: {
                p: `<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" stroke-width="1.5"/></svg>`,
                r: `<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" stroke="none"/></g></svg>`,
                n: `<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#ffffff; stroke:#000000;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.17,5.37 16.5,4 16.5,4 C 16.5,4 18.5,4 21,4.5 C 20,6.37 16,8.5 16,8.5 C 16,8.5 19,10 19,10 C 19,10 24.4,10 26.2,12.4 C 27.86,14.72 27.5,18.5 27.5,18.5 C 27.5,18.5 26,19.5 26,20 C 26,20 24.6,20.4 24,20 C 22.2,19.2 24,18 24,18 z" style="fill:#ffffff; stroke:#000000;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#000000; stroke:#000000;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)" style="fill:#000000; stroke:#000000;"/></g></svg>`,
                b: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#fff" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 0 2 .5 3H8.5c.5-1 .5-3 .5-3z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke="#000" stroke-linejoin="miter"/></g></svg>`,
                q: `<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM11 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM38 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 2.5 4 4.5 1 12 1s9.5 3 12-1c1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none"/></g></svg>`,
                k: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10c-1.5-2.5-6-2.5-6 0-1.5 2.5 3 10 3 10" fill="#fff" stroke-linecap="butt"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0V27s10-4.5 6-10.5c-4-6-9.5-3.5-9.5-3.5l-6.5 8h-2l-6.5-8s-5.5-2.5-9.5 3.5c-4 6 6 10.5 6 10.5v10z" fill="#fff"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>`
            },
            b: {
                p: `<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#fff" stroke-width="1.5"/></svg>`,
                r: `<svg viewBox="0 0 45 45"><g fill="#000" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" stroke="none"/></g></svg>`,
                n: `<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#000000; stroke:#ffffff;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.17,5.37 16.5,4 16.5,4 C 16.5,4 18.5,4 21,4.5 C 20,6.37 16,8.5 16,8.5 C 16,8.5 19,10 19,10 C 19,10 24.4,10 26.2,12.4 C 27.86,14.72 27.5,18.5 27.5,18.5 C 27.5,18.5 26,19.5 26,20 C 26,20 24.6,20.4 24,20 C 22.2,19.2 24,18 24,18 z" style="fill:#000000; stroke:#ffffff;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#ffffff; stroke:#ffffff;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)" style="fill:#ffffff; stroke:#ffffff;"/></g></svg>`,
                b: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#000" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 0 2 .5 3H8.5c.5-1 .5-3 .5-3z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke="#fff" stroke-linejoin="miter"/></g></svg>`,
                q: `<svg viewBox="0 0 45 45"><g fill="#000" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM11 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM38 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 2.5 4 4.5 1 12 1s9.5 3 12-1c1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none"/></g></svg>`,
                k: `<svg viewBox="0 0 45 45"><g fill="none" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10c-1.5-2.5-6-2.5-6 0-1.5 2.5 3 10 3 10" fill="#000" stroke-linecap="butt"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0V27s10-4.5 6-10.5c-4-6-9.5-3.5-9.5-3.5l-6.5 8h-2l-6.5-8s-5.5-2.5-9.5 3.5c-4 6 6 10.5 6 10.5v10z" fill="#000"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>`
            }
        };

        // --- Game Logic ---
        const boardElement = document.getElementById('board');
        const statusText = document.getElementById('status-text');
        const turnIndicator = document.getElementById('turn-indicator');
        const moveLog = document.getElementById('move-log');
        const capturedWhite = document.getElementById('captured-white');
        const capturedBlack = document.getElementById('captured-black');

        let board = [];
        let turn = 'w';
        let selectedSquare = null;
        let validMoves = [];
        let history = []; // Array of algebraic strings
        let captured = { w: [], b: [] };
        let isGameOver = false;

        // Advanced states
        let hasMoved = { wK: false, wR1: false, wR2: false, bK: false, bR1: false, bR2: false };
        let lastMove = null; // { from: {r, c}, to: {r, c}, piece: '' }

        function initBoard() {
            board = [
                ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
                ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
            ];
            turn = 'w';
            selectedSquare = null;
            validMoves = [];
            history = [];
            captured = { w: [], b: [] };
            isGameOver = false;
            hasMoved = { wK: false, wR1: false, wR2: false, bK: false, bR1: false, bR2: false };
            lastMove = null;

            renderBoard();
            updateStatus();
            moveLog.innerHTML = '<p class="text-zinc-500 italic col-span-3 text-center pt-4">No moves yet...</p>';
            capturedWhite.innerHTML = '';
            capturedBlack.innerHTML = '';
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            
            // Find King position if in check for visual highlighting
            let kingInCheckPos = null;
            if (isInCheck(turn, board)) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === turn + 'k') {
                            kingInCheckPos = { r, c };
                            break;
                        }
                    }
                }
            }

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    
                    // Highlight last move
                    if (lastMove && ((lastMove.from.r === r && lastMove.from.c === c) || (lastMove.to.r === r && lastMove.to.c === c))) {
                        square.classList.add('last-move');
                    }

                    // Highlight Check
                    if (kingInCheckPos && kingInCheckPos.r === r && kingInCheckPos.c === c) {
                        square.classList.add('check');
                    }

                    const piece = board[r][c];
                    if (piece) {
                        const pieceDiv = document.createElement('div');
                        pieceDiv.className = 'piece';
                        pieceDiv.innerHTML = PIECES_SVG[piece[0]][piece[1]];
                        square.appendChild(pieceDiv);
                    }

                    if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) {
                        square.classList.add('selected');
                    }

                    const move = validMoves.find(m => m.r === r && m.c === c);
                    if (move) {
                        const indicator = document.createElement('div');
                        indicator.className = move.capture ? 'capture-ring' : 'move-dot';
                        square.appendChild(indicator);
                    }

                    square.onclick = () => handleSquareClick(r, c);
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(r, c) {
            if (isGameOver) return;

            const clickedPiece = board[r][c];
            const move = validMoves.find(m => m.r === r && m.c === c);

            if (move) {
                executeMove(selectedSquare, move);
            } else if (clickedPiece && clickedPiece[0] === turn) {
                selectedSquare = { r, c };
                validMoves = getValidMoves(r, c, board);
                renderBoard();
            } else {
                selectedSquare = null;
                validMoves = [];
                renderBoard();
            }
        }

        function executeMove(from, to) {
            const piece = board[from.r][from.c];
            const color = piece[0];
            const type = piece[1];
            let target = board[to.r][to.c];
            let isEnPassant = false;
            let algebraic = "";

            // Handle Castling
            if (type === 'k' && Math.abs(to.c - from.c) === 2) {
                const isKingside = to.c === 6;
                const rookCol = isKingside ? 7 : 0;
                const newRookCol = isKingside ? 5 : 3;
                board[from.r][newRookCol] = board[from.r][rookCol];
                board[from.r][rookCol] = null;
                algebraic = isKingside ? "O-O" : "O-O-O";
            } else {
                // Build Algebraic notation
                if (type !== 'p') algebraic += type.toUpperCase();
                if (target) algebraic += 'x';
                algebraic += String.fromCharCode(97 + to.c) + (8 - to.r);
            }

            // Handle En Passant Capture
            if (type === 'p' && !target && from.c !== to.c) {
                target = board[from.r][to.c]; // The pawn being captured
                board[from.r][to.c] = null;
                isEnPassant = true;
                algebraic = `${String.fromCharCode(97 + from.c)}x${String.fromCharCode(97 + to.c)}${8 - to.r}`;
            }

            if (target) {
                captured[target[0]].push(target[1]);
                updateCapturedDisplay();
            }

            // Move piece
            board[to.r][to.c] = piece;
            board[from.r][from.c] = null;

            // Pawn Promotion (Auto-Queen)
            if (type === 'p' && (to.r === 0 || to.r === 7)) {
                board[to.r][to.c] = piece[0] + 'q';
                algebraic += "=Q";
            }

            // Update move trackers
            lastMove = { from, to, piece };
            if (type === 'k') hasMoved[color + 'K'] = true;
            if (type === 'r') {
                if (from.r === (color === 'w' ? 7 : 0)) {
                    if (from.c === 0) hasMoved[color + 'R1'] = true;
                    if (from.c === 7) hasMoved[color + 'R2'] = true;
                }
            }

            history.push(algebraic);
            updateLog(algebraic);

            turn = turn === 'w' ? 'b' : 'w';
            selectedSquare = null;
            validMoves = [];
            
            // Check for game state
            if (isCheckmate(turn)) {
                isGameOver = true;
                const winner = turn === 'w' ? 'Black' : 'White';
                statusText.innerText = `CHECKMATE! ${winner} Wins!`;
                statusText.classList.add('text-red-500');
                history[history.length-1] += "#";
            } else if (isInCheck(turn, board)) {
                statusText.innerText = `${turn === 'w' ? 'White' : 'Black'}'s Turn (CHECK)`;
                history[history.length-1] += "+";
            } else if (isStalemate(turn)) {
                isGameOver = true;
                statusText.innerText = "Stalemate! It's a Draw.";
                statusText.classList.add('text-yellow-500');
            }

            renderBoard();
            updateStatus();
        }

        function getValidMoves(r, c, currentBoard, checkSafety = true) {
            const piece = currentBoard[r][c];
            if (!piece) return [];
            
            const color = piece[0];
            const type = piece[1];
            let moves = [];

            const directions = {
                r: [[0, 1], [0, -1], [1, 0], [-1, 0]],
                b: [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                n: [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]],
                k: [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
            };

            if (type === 'p') {
                const dir = color === 'w' ? -1 : 1;
                const startRow = color === 'w' ? 6 : 1;
                
                // Normal move
                if (r + dir >= 0 && r + dir < 8 && !currentBoard[r + dir][c]) {
                    moves.push({ r: r + dir, c, capture: false });
                    if (r === startRow && !currentBoard[r + 2 * dir][c]) {
                        moves.push({ r: r + 2 * dir, c, capture: false });
                    }
                }
                // Captures
                for (let dc of [-1, 1]) {
                    if (r + dir >= 0 && r + dir < 8 && c + dc >= 0 && c + dc < 8) {
                        const target = currentBoard[r + dir][c + dc];
                        if (target && target[0] !== color) {
                            moves.push({ r: r + dir, c: c + dc, capture: true });
                        }
                        // En Passant
                        if (!target && lastMove && lastMove.piece === (color === 'w' ? 'bp' : 'wp')) {
                            if (lastMove.to.r === r && lastMove.to.c === c + dc && Math.abs(lastMove.from.r - lastMove.to.r) === 2) {
                                moves.push({ r: r + dir, c: c + dc, capture: true, enPassant: true });
                            }
                        }
                    }
                }
            } else if (type === 'r' || type === 'b' || type === 'q') {
                const dirs = type === 'q' ? [...directions.r, ...directions.b] : directions[type];
                for (let [dr, dc] of dirs) {
                    let nr = r + dr, nc = c + dc;
                    while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        const target = currentBoard[nr][nc];
                        if (!target) {
                            moves.push({ r: nr, c: nc, capture: false });
                        } else {
                            if (target[0] !== color) moves.push({ r: nr, c: nc, capture: true });
                            break;
                        }
                        nr += dr; nc += dc;
                    }
                }
            } else if (type === 'n' || type === 'k') {
                for (let [dr, dc] of directions[type]) {
                    const nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        const target = currentBoard[nr][nc];
                        if (!target || target[0] !== color) {
                            moves.push({ r: nr, c: nc, capture: !!target });
                        }
                    }
                }

                // Castling Logic
                if (type === 'k' && checkSafety && !isInCheck(color, currentBoard)) {
                    // Kingside
                    if (!hasMoved[color + 'K'] && !hasMoved[color + 'R2']) {
                        if (!currentBoard[r][5] && !currentBoard[r][6]) {
                            if (isSquareSafe(r, 5, color, currentBoard)) moves.push({ r, c: 6, capture: false });
                        }
                    }
                    // Queenside
                    if (!hasMoved[color + 'K'] && !hasMoved[color + 'R1']) {
                        if (!currentBoard[r][1] && !currentBoard[r][2] && !currentBoard[r][3]) {
                            if (isSquareSafe(r, 3, color, currentBoard)) moves.push({ r, c: 2, capture: false });
                        }
                    }
                }
            }

            if (checkSafety) {
                return moves.filter(m => {
                    const tempBoard = currentBoard.map(row => [...row]);
                    // If en passant, manually remove the captured pawn for safety check
                    if (type === 'p' && !currentBoard[m.r][m.c] && c !== m.c) {
                        tempBoard[r][m.c] = null;
                    }
                    tempBoard[m.r][m.c] = tempBoard[r][c];
                    tempBoard[r][c] = null;
                    return !isInCheck(color, tempBoard);
                });
            }

            return moves;
        }

        function isSquareSafe(r, c, color, currentBoard) {
            for (let ir = 0; ir < 8; ir++) {
                for (let ic = 0; ic < 8; ic++) {
                    const piece = currentBoard[ir][ic];
                    if (piece && piece[0] !== color) {
                        const attacks = getValidMoves(ir, ic, currentBoard, false);
                        if (attacks.some(m => m.r === r && m.c === c)) return false;
                    }
                }
            }
            return true;
        }

        function isInCheck(color, checkBoard) {
            let kingPos = null;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (checkBoard[r][c] === color + 'k') {
                        kingPos = { r, c }; break;
                    }
                }
                if (kingPos) break;
            }
            if (!kingPos) return false;
            return !isSquareSafe(kingPos.r, kingPos.c, color, checkBoard);
        }

        function isCheckmate(color) {
            if (!isInCheck(color, board)) return false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece[0] === color) {
                        if (getValidMoves(r, c, board).length > 0) return false;
                    }
                }
            }
            return true;
        }

        function isStalemate(color) {
            if (isInCheck(color, board)) return false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece[0] === color) {
                        if (getValidMoves(r, c, board).length > 0) return false;
                    }
                }
            }
            return true;
        }

        function updateStatus() {
            if (isGameOver) return;
            statusText.innerText = `${turn === 'w' ? 'White' : 'Black'}'s Turn`;
            statusText.classList.remove('text-red-500', 'text-yellow-500');
            turnIndicator.style.backgroundColor = turn === 'w' ? 'white' : 'black';
        }

        function updateLog(move) {
            if (history.length === 1) moveLog.innerHTML = '';
            const moveNum = Math.ceil(history.length / 2);
            
            if (history.length % 2 !== 0) {
                // White move
                const numSpan = document.createElement('div');
                numSpan.className = "text-zinc-500 text-right pr-4";
                numSpan.innerText = `${moveNum}.`;
                
                const wMoveSpan = document.createElement('div');
                wMoveSpan.className = "font-medium text-white";
                wMoveSpan.innerText = move;
                
                moveLog.appendChild(numSpan);
                moveLog.appendChild(wMoveSpan);
            } else {
                // Black move
                const bMoveSpan = document.createElement('div');
                bMoveSpan.className = "font-medium text-zinc-300";
                bMoveSpan.innerText = move;
                moveLog.appendChild(bMoveSpan);
            }
            moveLog.scrollTop = moveLog.scrollHeight;
        }

        function updateCapturedDisplay() {
            capturedWhite.innerHTML = captured.w.map(p => `<span class="opacity-70 scale-75 block w-5 h-5">${PIECES_SVG.w[p]}</span>`).join('');
            capturedBlack.innerHTML = captured.b.map(p => `<span class="opacity-70 scale-75 block w-5 h-5">${PIECES_SVG.b[p]}</span>`).join('');
        }

        document.getElementById('reset-btn').onclick = initBoard;

        document.getElementById('pgn-btn').onclick = () => {
            let pgn = "";
            for (let i = 0; i < history.length; i++) {
                if (i % 2 === 0) pgn += `${Math.floor(i/2) + 1}. `;
                pgn += history[i] + " ";
            }
            navigator.clipboard.writeText(pgn.trim()).then(() => {
                const btn = document.getElementById('pgn-btn');
                const oldText = btn.innerText;
                btn.innerText = "COPIED!";
                setTimeout(() => btn.innerText = oldText, 2000);
            });
        };

        window.onload = initBoard;
    </script>
</body>
</html>