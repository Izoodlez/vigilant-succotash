<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Poker - Multiplayer</title>
    <style>
        :root {
            --bg-dark: #1a1a1a;
            --table-color: #35654d;
            --accent-gold: #ffbd2e;
            --accent-blue: #3498db;
            --accent-red: #e74c3c;
            --text-main: #ffffff;
            --text-muted: #aab7b8;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            background: linear-gradient(135deg, var(--bg-dark) 0%, #2d1e1e 100%);
            color: var(--text-main);
            font-family: 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: rgba(0,0,0,0.8);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-gold);
        }

        .brand {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-gold);
        }

        .header-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary { background: var(--accent-gold); color: #000; }
        .btn-primary:hover { background: #ffca57; transform: translateY(-2px); }
        .btn-secondary { background: var(--accent-blue); color: #fff; }
        .btn-secondary:hover { background: #5dade2; }
        .btn-danger { background: var(--accent-red); color: #fff; }
        .btn:disabled { background: #555; cursor: not-allowed; opacity: 0.5; }

        main {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
        }

        .game-area {
            flex: 1;
            background: radial-gradient(circle, var(--table-color) 0%, #1e3b2d 100%);
            border: 20px solid #3e2723;
            border-radius: 20px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .sidebar {
            width: 300px;
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
        }

        .section h3 {
            color: var(--accent-gold);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .player-card {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }

        .player-card.active-turn {
            border-color: var(--accent-gold);
            background: rgba(255,189,46,0.1);
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--accent-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .player-avatar.bot { background: #27ae60; }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .player-score {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .turn-indicator {
            color: var(--accent-gold);
            font-size: 1.5rem;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .dice-container {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .die {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            color: #000;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .die:hover:not(.disabled) { transform: translateY(-5px); }
        .die.held { 
            background: var(--accent-gold); 
            box-shadow: 0 0 20px rgba(255,189,46,0.5);
        }
        .die.disabled { cursor: not-allowed; opacity: 0.5; }

        .game-status {
            font-size: 1.3rem;
            margin: 20px 0;
            color: var(--accent-gold);
            text-align: center;
        }

        .game-info {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            font-size: 1.1rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .info-label {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .info-value {
            color: var(--accent-gold);
            font-size: 1.3rem;
            font-weight: bold;
        }

        .hand-result {
            margin-top: 20px;
            padding: 15px 30px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            font-size: 1.2rem;
            color: var(--accent-gold);
            text-align: center;
            min-height: 50px;
        }

        #toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            border: 2px solid var(--accent-gold);
            font-size: 1rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #toast.show { opacity: 1; }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal.active { display: flex; }

        .modal-content {
            background: #1a1a1a;
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 2rem;
            color: var(--accent-gold);
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }

        .score-row-item {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .score-row-item.winner {
            border-color: var(--accent-gold);
            background: rgba(255,189,46,0.1);
        }

        .winner-badge {
            background: var(--accent-gold);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
        }

        .lobby-code {
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            color: var(--accent-gold);
        }

        .betting-section {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .betting-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .betting-controls button {
            padding: 8px 12px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .betting-controls button:hover {
            background: #5dade2;
            transform: translateY(-2px);
        }

        .bet-display {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .bet-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .bet-label {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .bet-value {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 1.3rem;
        }

        .pot-display {
            background: rgba(255,189,46,0.2);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .pot-value {
            font-size: 2rem;
            color: var(--accent-gold);
            font-weight: bold;
        }

        .player-card.folded {
            opacity: 0.5;
            border-color: var(--accent-red);
        }

        .player-chips {
            font-size: 0.75rem;
            color: var(--accent-gold);
        }

        .btn-success { background: var(--accent-green); color: #fff; }

        .ready-section {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .waiting-on-players {
            font-size: 1rem;
            color: var(--text-muted);
            margin-bottom: 15px;
            min-height: 24px;
        }

        .ready-badge {
            display: inline-block;
            background: #27ae60;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 5px;
        }

        .call-confirmation {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .call-amount {
            font-size: 1.8rem;
            color: var(--accent-gold);
            font-weight: bold;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <header>
        <div class="brand">üé≤ Dice Poker - Multiplayer</div>
        <div class="header-right">
            <div class="lobby-code">Lobby: <span id="lobby-code-display">...</span></div>
            <button class="btn btn-danger" onclick="returnToLobby()">Leave Game</button>
        </div>
    </header>

    <main>
        <div class="game-area">
            <div class="game-status" id="game-status">Waiting for game to start...</div>
            
            <!-- Ready-Up Section -->
            <div id="ready-section" class="ready-section" style="display: none;">
                <div style="font-size: 1.1rem; margin-bottom: 15px; font-weight: bold; color: var(--accent-gold);">Ready to Play?</div>
                <div class="waiting-on-players" id="waiting-on-display"></div>
                <button id="ready-btn" class="btn btn-primary" onclick="markPlayerReady()" style="margin-top: 10px; padding: 12px 30px; font-size: 1.1rem;">
                    ‚úì Ready
                </button>
            </div>
            
            <!-- Pot Display -->
            <div id="pot-display" class="pot-display" style="display: none;">
                <div class="bet-label">POT</div>
                <div class="pot-value" id="pot-value">0</div>
            </div>

            <!-- Betting Section -->
            <div id="betting-section" class="betting-section" style="display: none;">
                <div class="bet-display">
                    <div class="bet-item">
                        <div class="bet-label">Your Chips</div>
                        <div class="bet-value" id="player-chips">1000</div>
                    </div>
                    <div class="bet-item">
                        <div class="bet-label">Current Bet</div>
                        <div class="bet-value" id="bet-display">50</div>
                    </div>
                </div>
                <div id="betting-controls" class="betting-controls" style="display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap;">
                    <button onclick="adjustBet(10)">+10</button>
                    <button onclick="adjustBet(50)">+50</button>
                    <button onclick="adjustBet(100)">+100</button>
                    <button onclick="adjustBet(-10)">-10</button>
                    <button onclick="adjustBet(-50)">-50</button>
                    <button onclick="resetBet()">Reset</button>
                </div>
                <div id="call-confirmation" class="call-confirmation" style="display: none;">
                    <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 10px;">Call amount:</div>
                    <div class="call-amount" id="call-amount-display">0</div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button id="place-bet-btn" class="btn btn-primary" onclick="placeBet()" style="width: 150px;">
                        üí∞ Call
                    </button>
                    <button id="all-in-btn" class="btn btn-success" onclick="goAllIn()" style="width: 150px;">
                        üî• All In!
                    </button>
                    <button id="fold-btn" class="btn btn-danger" onclick="fold()" style="width: 150px;">
                        ‚ùå Fold
                    </button>
                </div>
            </div>
            
            <div class="dice-container" id="dice-container">
                <!-- Dice will be generated here -->
            </div>

            <div class="hand-result" id="hand-result">Place your bet to start!</div>

            <div style="display: flex; gap: 15px; margin-top: 30px;">
                <button id="roll-btn" class="btn btn-primary" onclick="rollDice()" disabled>
                    üé≤ Roll Dice
                </button>
                <button id="end-turn-btn" class="btn btn-secondary" onclick="endTurn()" disabled>
                    ‚úì End Turn
                </button>
            </div>

            <div class="game-info">
                <div class="info-item">
                    <div class="info-label">Rolls Left</div>
                    <div class="info-value" id="rolls-left">2</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Current Score</div>
                    <div class="info-value" id="current-score">0</div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="section">
                <h3>Players</h3>
                <div id="player-list-container">
                    <!-- Players will be rendered here -->
                </div>
            </div>

            <div class="section">
                <h3>Game Rules</h3>
                <p style="color: var(--text-muted); font-size: 0.9rem; line-height: 1.5;">
                    <strong>Poker Hands (High to Low):</strong><br>
                    Five of a Kind<br>
                    Four of a Kind<br>
                    Full House<br>
                    Straight<br>
                    Three of a Kind<br>
                    Two Pair<br>
                    One Pair<br><br>
                    <strong>How to Play:</strong><br>
                    1. First player sets the bet<br>
                    2. Other players call, go all-in, or fold<br>
                    3. Each player rolls twice (hold dice)<br>
                    4. Highest hand wins the pot!
                </p>
            </div>
        </div>
    </main>

    <!-- Scoreboard Modal -->
    <div id="scoreboardModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üèÜ Game Over!</div>
            <div id="scoreboardResults"></div>
            <div class="modal-actions">
                <button class="btn btn-primary" onclick="playAgain()">Play Again</button>
                <button class="btn btn-secondary" onclick="returnToLobbyFromScoreboard()">Return to Lobby</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast"></div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

    <!-- Firebase Config -->
    <script src="../../js/firebaseConfig.js"></script>

    <script>
        // ==============================
        // FIREBASE & LOBBY STATE
        // ==============================
        // Note: db, auth, playerUUID are already declared in firebaseConfig.js
        let lobbyId = null;
        let lobbyRef = null;
        let lobbyPlayers = {};
        let currentMatchState = null;
        let scoreboardShown = false;
        let gameStarted = false;
        let hasFolded = false;
        const GAME_TYPE = 'dicepoker';
        
        // ==============================
        // BETTING & CHIPS
        // ==============================
        const STARTING_CHIPS = 1000;
        let playerChips = {};
        let currentBet = 50;
        let currentPot = 0;
        let firstPlayerBet = 50;

        // ==============================
        // GAME STATE
        // ==============================
        let dice = [1, 2, 3, 4, 5];
        let heldDice = [false, false, false, false, false];
        let rollsLeft = 2;
        let currentScore = 0;
        let currentLobbyKey = null;
        let gameInitialized = false;
        let bettingStarted = false;
        let bettingStarter = null;
        let isBettingCheckInProgress = false;
        let isRollingCheckInProgress = false;
        let isReadyCheckInProgress = false;
        let playerTurnComplete = false; // Track if current player completed their turn

        // ==============================
        // INITIALIZATION
        // ==============================
        window.addEventListener('load', async () => {
            // Ensure Firebase is initialized and playerUUID is ready
            const initialized = await ensureFirebaseInitialized();
            if (!playerUUID) {
                console.error('Failed to initialize playerUUID');
                showToast('Error initializing player');
                return;
            }
            
            console.log('playerUUID ready:', playerUUID);
            const hasLobby = await joinLobbyFromURL();
            if (!hasLobby) return; // Stop initialization if no lobby found
            setupRealtimeSync();
            renderDice();
        });

        function initializeFirebase() {
            if (typeof firebase === 'undefined') {
                console.error('Firebase not loaded!');
                return;
            }
            // Firebase should already be initialized by firebaseConfig.js
            // Just ensure db and auth are available
            if (!db) db = firebase.database();
            if (!auth) auth = firebase.auth();
            console.log('Firebase verified');
        }

        async function initializeAuth() {
            return new Promise((resolve) => {
                auth.onAuthStateChanged(async (user) => {
                    if (!user) {
                        try {
                            await auth.signInAnonymously();
                        } catch (error) {
                            console.error('Auth failed:', error);
                        }
                    }
                    
                    // Ensure playerUUID is set from sessionStorage or generate a new one
                    if (!playerUUID) {
                        playerUUID = sessionStorage.getItem('playerUUID');
                        if (!playerUUID) {
                            playerUUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                                const r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
                                return v.toString(16);
                            });
                            sessionStorage.setItem('playerUUID', playerUUID);
                        }
                    }
                    
                    console.log('Auth initialized, playerUUID:', playerUUID);
                    resolve();
                });
            });
        }

        async function joinLobbyFromURL() {
            const params = new URLSearchParams(window.location.search);
            lobbyId = params.get('lobbyId');
            
            if (!lobbyId) {
                console.warn('No lobby ID found in URL. Redirecting to lobby page...');
                window.location.href = '../../lobby.html';
                return false;
            }

            try {
                // Join the lobby using the helper function (adds us to players list)
                console.log('Joining lobby via URL:', lobbyId);
                
                // Get the username from sessionStorage (set when player entered lobby)
                const username = sessionStorage.getItem('playerUsername') || sessionStorage.getItem('currentPlayerName');
                console.log('Joining with username:', username);
                
                const result = await joinLobby(lobbyId, username);
                
                // Update playerUUID from the result
                if (result && result.playerId) {
                    playerUUID = result.playerId;
                    sessionStorage.setItem('playerUUID', playerUUID);
                }
                
                // Store locally for later use
                window.currentLobbyId = lobbyId;
                sessionStorage.setItem('currentLobbyId', lobbyId);
                
                // Fetch lobby data to get the key
                const lobbySnapshot = await db.ref(`lobbies/${lobbyId}`).once('value');
                const lobbyData = lobbySnapshot.val();
                
                if (lobbyData && lobbyData.key) {
                    currentLobbyKey = lobbyData.key;
                    document.getElementById('lobby-code-display').textContent = currentLobbyKey;
                } else {
                    document.getElementById('lobby-code-display').textContent = lobbyId.slice(0, 6);
                }
                
                // Initialize players from lobby
                lobbyPlayers = lobbyData.players || {};
                
                // Reset chips if player is broke
                const playerRef = db.ref(`lobbies/${lobbyId}/players/${playerUUID}`);
                const playerSnapshot = await playerRef.once('value');
                const playerData = playerSnapshot.val();
                
                if (playerData && (playerData.chips === undefined || playerData.chips <= 0)) {
                    await playerRef.update({ chips: STARTING_CHIPS });
                }
                
                console.log('Successfully joined lobby, key:', currentLobbyKey, 'playerUUID:', playerUUID);
                return true;
            } catch (error) {
                console.error('Error joining lobby from URL:', error);
                showToast('Error joining lobby: ' + error.message);
                setTimeout(() => {
                    window.location.href = '../../lobby.html';
                }, 2000);
                return false;
            }
        }

        function setupRealtimeSync() {
            if (!lobbyId) {
                console.error('No lobbyId set, cannot setup sync');
                return;
            }

            console.log('Setting up real-time sync for lobby:', lobbyId);
            
            // Attach lobby listener
            lobbyRef = onLobbyUpdate((data) => {
                if (!data) {
                    console.warn('No data received from onLobbyUpdate');
                    return;
                }

                console.log('Lobby data updated:', data);
                
                // Update players list
                lobbyPlayers = data.players || {};
                
                // Update match state (game-specific)
                const gameState = data.gameStates && data.gameStates[GAME_TYPE];
                if (gameState) {
                    currentMatchState = gameState;
                    
                    // Ensure playerStates object exists
                    if (!currentMatchState.playerStates) {
                        currentMatchState.playerStates = {};
                    }
                    
                    // Initialize player states for any new players
                    Object.keys(lobbyPlayers).forEach(playerId => {
                        if (!currentMatchState.playerStates[playerId]) {
                            currentMatchState.playerStates[playerId] = {
                                ready: lobbyPlayers[playerId].isBot ? true : false,
                                score: 0
                            };
                        }
                    });
                } else {
                    currentMatchState = currentMatchState || {};
                    if (!currentMatchState.playerStates) {
                        currentMatchState.playerStates = {};
                    }
                }
                
                // Update player chips from Firebase
                Object.entries(lobbyPlayers).forEach(([pid, player]) => {
                    playerChips[pid] = player.chips !== undefined ? player.chips : STARTING_CHIPS;
                });
                
                console.log('Players in lobby:', Object.keys(lobbyPlayers).length, lobbyPlayers);
                console.log('Match state:', currentMatchState);
                
                // Update UI
                syncFromFirebase(currentMatchState);
                updatePlayerList();
                handleTurnLogic();
                updateGameStatus();
                updatePotDisplay();
                updateReadySection();
                
                // Host should check if all players are ready during waiting phase
                if (isHostClient() && currentMatchState && currentMatchState.status === 'waiting' && !isReadyCheckInProgress) {
                    checkAllPlayersReady();
                }
                
                // Host should check if betting phase is complete whenever state updates (with debounce)
                if (isHostClient() && currentMatchState && currentMatchState.status === 'betting' && !isBettingCheckInProgress) {
                    checkBettingPhaseComplete();
                }
                
                // Host should check if rolling phase is complete whenever state updates (with debounce)
                if (isHostClient() && currentMatchState && currentMatchState.status === 'playing' && !isRollingCheckInProgress) {
                    checkRollingPhaseComplete();
                }
                
                // Initialize game on first load
                checkAndStartGame();
            }, lobbyId);
            
            window.globalLobbyRef = lobbyRef;
        }

        function checkAndStartGame() {
            // Initialize match state if it doesn't exist yet
            console.log('checkAndStartGame - currentMatchState:', currentMatchState, 'Object.keys.length:', Object.keys(currentMatchState || {}).length, 'gameInitialized:', gameInitialized);
            
            if (!currentMatchState || Object.keys(currentMatchState).length === 0) {
                // Try to initialize if we're the host
                const realPlayers = Object.entries(lobbyPlayers).filter(([_, p]) => !p.isBot);
                console.log('No game state yet - realPlayers:', realPlayers.length, 'isHostClient:', isHostClient());
                if (isHostClient() && !gameInitialized && realPlayers.length >= 2) {
                    console.log('First time setup - starting game round with waiting status');
                    gameInitialized = true;
                    startGameRound().catch(err => {
                        console.error('startGameRound failed:', err);
                        gameInitialized = false;
                    });
                }
            } else if (currentMatchState && currentMatchState.status === 'waiting' && !gameInitialized) {
                const realPlayers = Object.values(lobbyPlayers).filter(p => !p.isBot);
                console.log('Game in waiting state - realPlayers:', realPlayers.length);
                if (realPlayers.length > 0) {
                    console.log('Game entered waiting state with players. Showing ready-up UI.');
                    gameInitialized = true;
                }
            } else if (currentMatchState && !currentMatchState.status && !gameInitialized && Object.keys(lobbyPlayers).length >= 2) {
                // Fallback: if game state exists but has no status after 2+ players, force it to waiting
                console.log('Game state exists but no status - forcing to waiting mode');
                gameInitialized = true;
                // Force update to waiting if we're the host
                if (isHostClient()) {
                    const playerStates = {};
                    Object.keys(lobbyPlayers).forEach(playerId => {
                        playerStates[playerId] = {
                            ready: lobbyPlayers[playerId].isBot ? true : false,
                            score: 0
                        };
                    });
                    const turnOrder = Object.keys(lobbyPlayers);
                    updateGameSpecificState(GAME_TYPE, {
                        status: 'waiting',
                        turnOrder: turnOrder,
                        currentTurn: turnOrder[0] || null,
                        playerStates: playerStates
                    }, lobbyId).catch(err => console.error('Force update failed:', err));
                }
            }
        }

        function updateReadySection() {
            const readySection = document.getElementById('ready-section');
            const waitingDisplay = document.getElementById('waiting-on-display');
            const readyBtn = document.getElementById('ready-btn');
            
            console.log('updateReadySection - currentMatchState:', currentMatchState, 'status:', currentMatchState?.status);
            
            if (!currentMatchState || currentMatchState.status !== 'waiting') {
                if (readySection) readySection.style.display = 'none';
                return;
            }
            
            if (readySection) readySection.style.display = 'block';
            
            // Get list of human players who are not ready
            const playerStates = currentMatchState.playerStates || {};
            const notReadyPlayers = [];
            
            Object.entries(lobbyPlayers).forEach(([playerId, player]) => {
                if (!player.isBot) {
                    const playerState = playerStates[playerId] || {};
                    if (!playerState.ready) {
                        notReadyPlayers.push(player.name || `Player-${playerId.slice(0, 4)}`);
                    }
                }
            });
            
            // Update waiting display
            if (notReadyPlayers.length === 0) {
                waitingDisplay.innerHTML = '<span style="color: #27ae60; font-weight: bold;">All players ready! Starting game...</span>';
                if (readyBtn) readyBtn.disabled = true;
            } else {
                const isCurrentPlayerReady = (playerStates[playerUUID] || {}).ready;
                waitingDisplay.innerHTML = `Waiting on: <strong>${notReadyPlayers.join(', ')}</strong>`;
                if (readyBtn) readyBtn.disabled = isCurrentPlayerReady;
            }
        }

        async function markPlayerReady() {
            if (!lobbyId || !playerUUID) return;
            
            try {
                // Update player ready status in Firebase
                await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}/playerStates/${playerUUID}`).update({
                    ready: true
                });
                
                console.log('Player marked as ready');
                showToast('You are ready!');
                
                // Disable the button
                document.getElementById('ready-btn').disabled = true;
                
                // Check if all humans are ready (host will auto-transition)
                if (isHostClient()) {
                    setTimeout(checkAllPlayersReady, 500);
                }
            } catch (error) {
                console.error('Error marking player ready:', error);
                showToast('Error marking ready');
            }
        }

        async function checkAllPlayersReady() {
            if (!currentMatchState || currentMatchState.status !== 'waiting') return;
            if (!isHostClient()) return;
            if (isReadyCheckInProgress) return;
            
            isReadyCheckInProgress = true;
            
            try {
                const playerStates = currentMatchState.playerStates || {};
                
                // Check if all human players are ready
                const allHumansReady = Object.entries(lobbyPlayers).every(([playerId, player]) => {
                    if (player.isBot) return true; // Bots are always ready
                    const state = playerStates[playerId] || {};
                    return state.ready === true;
                });
                
                if (allHumansReady) {
                    console.log('All humans ready! Transitioning to betting phase...');
                    await startBettingPhase();
                }
            } finally {
                isReadyCheckInProgress = false;
            }
        }

        function handleTurnLogic() {
            if (!currentMatchState) {
                console.log('No match state defined');
                return;
            }
            
            console.log('handleTurnLogic - status:', currentMatchState.status, 'currentTurn:', currentMatchState.currentTurn, 'myUUID:', playerUUID);
            
            // If game is not in an active phase, don't process turn logic
            if (!currentMatchState.status || (currentMatchState.status !== 'betting' && currentMatchState.status !== 'playing')) {
                console.log('Game not in active phase, status:', currentMatchState.status);
                return;
            }
            
            // If currentTurn is not set but we're in betting/playing, wait and retry
            if (!currentMatchState.currentTurn) {
                console.log('No current turn defined yet, retrying...');
                setTimeout(handleTurnLogic, 500);
                return;
            }
            
            const isMyTurn = currentMatchState.currentTurn === playerUUID;
            const currentPlayer = lobbyPlayers[currentMatchState.currentTurn];
            
            console.log('isMyTurn:', isMyTurn, 'currentPlayer:', currentPlayer?.name, 'myName:', lobbyPlayers[playerUUID]?.name);
            
            // Reset turn complete flag when it becomes our turn
            if (isMyTurn && playerTurnComplete) {
                console.log('It is now my turn - resetting playerTurnComplete flag');
                playerTurnComplete = false;
            }
            
            if (currentMatchState.status === 'betting') {
                console.log('Betting phase - isMyTurn:', isMyTurn);
                // Only allow betting controls during betting phase
                if (isMyTurn && !hasFolded) {
                    enableBettingControls();
                    showToast("Your turn to bet!");
                } else {
                    disableBettingControls();
                }
                // Bot betting
                if (isHostClient() && currentPlayer && currentPlayer.isBot) {
                    setTimeout(() => runBotBet(currentMatchState.currentTurn), 2000);
                }
                disableRollingControls();
                return;
            }

            // After betting phase, only rolling and gameplay actions should be enabled
            disableBettingControls();
            if (currentMatchState.status === 'playing') {
                console.log('Playing phase - isMyTurn:', isMyTurn, 'playerTurnComplete:', playerTurnComplete);
                bettingStarted = false;
                if (isMyTurn && !hasFolded && !playerTurnComplete) {
                    enableRollingControls();
                    showToast("Your turn to roll!");
                } else {
                    disableControls();
                }
                // Bot rolling
                if (isHostClient() && currentPlayer && currentPlayer.isBot) {
                    setTimeout(() => runBotRoll(currentMatchState.currentTurn), 2000);
                }
                return;
            }
        }

        function syncFromFirebase(matchState) {
            if (!matchState) return;
            
            if (matchState.pot !== undefined) {
                currentPot = matchState.pot;
            }
            
            if (matchState.currentBet !== undefined) {
                firstPlayerBet = matchState.currentBet;
                updateBetDisplay();
            }
            
            if (matchState.bettingStarter) {
                bettingStarter = matchState.bettingStarter;
            }
            
            if (matchState.gameOver && !scoreboardShown) {
                const rankings = matchState.rankings || [];
                const winner = matchState.winner;
                showScoreboard(rankings, winner);
            }
        }

        function updatePlayerList() {
            const container = document.getElementById('player-list-container');
            if (!container) {
                console.error('player-list-container not found!');
                return;
            }
            
            console.log('Updating player list, lobbyPlayers:', lobbyPlayers);
            container.innerHTML = '';

            if (Object.keys(lobbyPlayers).length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted);">No players yet...</p>';
                console.warn('No players found in lobby');
                return;
            }

            const matchState = currentMatchState || {};
            
            // Display all players in order
            Object.entries(lobbyPlayers).forEach(([playerId, player]) => {
                const isCurrentTurn = matchState.currentTurn === playerId;
                const playerFolded = matchState.folded && matchState.folded[playerId];
                const playerStates = matchState.playerStates || {};
                const playerState = playerStates[playerId] || {};
                const isMe = playerId === playerUUID;
                
                const card = document.createElement('div');
                card.className = `player-card ${isCurrentTurn ? 'active-turn' : ''} ${playerFolded ? 'folded' : ''}`;
                
                const avatar = player.isBot ? 'ü§ñ' : 'üë§';
                const turnIndicator = isCurrentTurn ? '<span class="turn-indicator">‚óÄ</span>' : '';
                const foldedText = playerFolded ? ' (FOLDED)' : '';
                const chips = player.chips !== undefined ? player.chips : STARTING_CHIPS;
                const readyBadge = (matchState.status === 'waiting' && playerState.ready && !player.isBot) ? '<span class="ready-badge">‚úì Ready</span>' : '';
                const youText = isMe ? ' (You)' : '';
                
                card.innerHTML = `
                    <div class="player-avatar ${player.isBot ? 'bot' : ''}">${avatar}</div>
                    <div class="player-info">
                        <div class="player-name">${player.name || 'Unknown'}${youText}${foldedText}</div>
                        <div class="player-score">Hand: ${getHandName(player.score) || 'Waiting'}</div>
                        <div class="player-chips">Chips: ${chips}</div>
                        ${readyBadge}
                    </div>
                    ${turnIndicator}
                `;
                
                container.appendChild(card);
            });
        }

        function updateGameStatus() {
            const statusEl = document.getElementById('game-status');
            
            if (!currentMatchState || !currentMatchState.status || currentMatchState.status === 'waiting') {
                const playerCount = Object.keys(lobbyPlayers).length;
                statusEl.textContent = playerCount > 0 ? `‚è≥ Starting game... (${playerCount} players)` : 'Waiting for players...';
            } else if (currentMatchState.status === 'betting') {
                const isMyTurn = currentMatchState.currentTurn === playerUUID;
                if (isMyTurn && !hasFolded) {
                    statusEl.textContent = "üí∞ Your Turn - Place Your Bet!";
                } else {
                    const currentPlayer = lobbyPlayers[currentMatchState.currentTurn];
                    const playerName = currentPlayer ? currentPlayer.name : 'Player';
                    statusEl.textContent = `‚è≥ Waiting for ${playerName} to bet...`;
                }
            } else if (currentMatchState.status === 'playing') {
                const isMyTurn = currentMatchState.currentTurn === playerUUID;
                if (isMyTurn && !hasFolded) {
                    statusEl.textContent = "üé≤ Your Turn - Roll the Dice!";
                } else {
                    const currentPlayer = lobbyPlayers[currentMatchState.currentTurn];
                    const playerName = currentPlayer ? currentPlayer.name : 'Player';
                    statusEl.textContent = `‚è≥ Waiting for ${playerName} to roll...`;
                }
            }
        }

        function updatePotDisplay() {
            const potDisplay = document.getElementById('pot-display');
            const potValue = document.getElementById('pot-value');
            
            if (currentPot > 0) {
                potDisplay.style.display = 'block';
                potValue.textContent = currentPot;
            } else {
                potDisplay.style.display = 'none';
            }
        }

        // ==============================
        // GAME INITIALIZATION & FLOW
        // ==============================
        async function startGameRound() {
            // Only host should call this, and only once
            if (!lobbyId || !db) return;
            
            console.log('startGameRound called - isHostClient:', isHostClient(), 'gameInitialized:', gameInitialized);
            
            // Check if game-specific state already exists
            const snapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
            if (snapshot.exists()) {
                console.log('Game state already initialized, skipping startGameRound');
                return;
            }
            
            // Only proceed if this player is the host
            if (!isHostClient()) {
                console.log('Not host client, skipping match state initialization');
                return;
            }
            
            console.log('Starting new game round as host');
            hasFolded = false;
            
            // Initialize player chips if not set
            Object.keys(lobbyPlayers).forEach(playerId => {
                if (playerChips[playerId] === undefined) {
                    playerChips[playerId] = STARTING_CHIPS;
                }
            });
            
            // Create turn order (all players including bots)
            const turnOrder = Object.keys(lobbyPlayers);
            
            // Initialize player states for ready-up
            const playerStates = {};
            Object.keys(lobbyPlayers).forEach(playerId => {
                playerStates[playerId] = {
                    ready: lobbyPlayers[playerId].isBot ? true : false,
                    score: 0
                };
            });
            
            // Update match state to waiting (for ready-up) - use game-specific namespace
            const matchStateUpdate = {
                status: 'waiting',
                round: (currentMatchState && currentMatchState.round) ? currentMatchState.round + 1 : 1,
                turnOrder: turnOrder,
                currentTurn: turnOrder[0] || null,
                pot: 0,
                currentBet: 0,
                playerBets: {},
                folded: {},
                completedBetting: {},
                completedRolling: {},
                playerStates: playerStates,
                gameOver: false,
                winner: null,
                rankings: null
            };
            
            // Update all player data and match state in Firebase
            const updates = {};
            Object.entries(playerChips).forEach(([pid, chips]) => {
                updates[`players/${pid}/chips`] = chips;
                updates[`players/${pid}/score`] = 0;
            });
            
            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, matchStateUpdate, lobbyId);
            
            console.log('Match state initialized with waiting status for ready-up');
        }

        async function startBettingPhase() {
            if (!lobbyId || !db) {
                console.error('Missing lobbyId or db in startBettingPhase');
                return;
            }
            if (!isHostClient()) {
                console.log('Not host client, skipping startBettingPhase');
                return;
            }
            
            console.log('All players ready! Starting betting phase...');
            console.log('Current lobbyPlayers:', lobbyPlayers);
            
            // Build a stable turn order if missing
            const orderedPlayers = (currentMatchState && currentMatchState.turnOrder && currentMatchState.turnOrder.length)
                ? currentMatchState.turnOrder
                : Object.keys(lobbyPlayers);

            console.log('Ordered players:', orderedPlayers);

            // Find the first human (non-bot) player in turn order
            let firstHuman = null;
            if (orderedPlayers && orderedPlayers.length) {
                for (const pid of orderedPlayers) {
                    console.log('Checking player:', pid, 'isBot:', lobbyPlayers[pid]?.isBot);
                    if (lobbyPlayers[pid] && !lobbyPlayers[pid].isBot) {
                        firstHuman = pid;
                        console.log('Found first human:', firstHuman);
                        break;
                    }
                }
            }
            
            // Fallback to first in turnOrder if no humans (shouldn't happen)
            const initialTurn = firstHuman || (orderedPlayers && orderedPlayers[0]) || null;
            
            if (!initialTurn) {
                console.error('No initial turn player found!');
                return;
            }
            
            console.log('Initial turn will be:', initialTurn, 'Player name:', lobbyPlayers[initialTurn]?.name);
            
            // Transition from waiting to betting with full state reset
            const betPhaseUpdate = {
                status: 'betting',
                turnOrder: orderedPlayers,
                currentTurn: initialTurn,
                pot: 0,
                currentBet: 50,
                firstPlayerBet: 50,
                playerBets: {},
                folded: {},
                completedBetting: {},
                completedRolling: {}
            };
            
            // Update Firebase and wait for completion
            console.log('Updating Firebase with betting phase, initialTurn:', initialTurn);
            try {
                await updateGameSpecificState(GAME_TYPE, betPhaseUpdate, lobbyId);
                console.log('Firebase updated successfully with status=betting and currentTurn=', initialTurn);
            } catch (error) {
                console.error('Error updating Firebase:', error);
                return;
            }
            
            // Don't update local state immediately - let Firebase propagation handle it
            // This ensures all clients get the same state at the same time
            showToast('Game started! First player to bet...');
        }

        // ==============================
        // BETTING LOGIC
        // ==============================
        function adjustBet(amount) {
            // Lock adjustments after first bet
            if (bettingStarted) return;
            
            const myChips = playerChips[playerUUID] || STARTING_CHIPS;
            const newBet = currentBet + amount;
            
            if (newBet > 0 && newBet <= myChips) {
                currentBet = newBet;
                updateBetDisplay();
            }
        }

        function resetBet() {
            currentBet = 50;
            updateBetDisplay();
        }

        function updateBetDisplay() {
            document.getElementById('bet-display').textContent = currentBet;
            document.getElementById('player-chips').textContent = playerChips[playerUUID] || STARTING_CHIPS;
        }

        function enableBettingControls() {
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'block';
            }
            
            // Check if this is the first bettor
            const isFirstBet = !currentMatchState.playerBets || Object.keys(currentMatchState.playerBets || {}).length === 0;
            const bettingControls = document.getElementById('betting-controls');
            const callConfirmation = document.getElementById('call-confirmation');
            
            if (isFirstBet) {
                // First bettor: show adjustment buttons
                if (bettingControls) bettingControls.style.display = 'flex';
                if (callConfirmation) callConfirmation.style.display = 'none';
            } else {
                // Subsequent bettors: show call confirmation
                if (bettingControls) bettingControls.style.display = 'none';
                if (callConfirmation) {
                    callConfirmation.style.display = 'block';
                    document.getElementById('call-amount-display').textContent = firstPlayerBet;
                    currentBet = firstPlayerBet;
                }
            }
            
            // Always update display
            updateBetDisplay();
        }

        function disableBettingControls() {
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'none';
            }
        }

        async function placeBet() {
            const myChips = playerChips[playerUUID] || STARTING_CHIPS;
            const betAmount = Math.min(currentBet, myChips);
            
            if (betAmount <= 0) {
                showToast('Invalid bet amount!');
                return;
            }
            
            playerChips[playerUUID] = myChips - betAmount;
            currentPot += betAmount;
            
            // Check if this is the FIRST bet
            const isFirstBet = !currentMatchState.playerBets || Object.keys(currentMatchState.playerBets || {}).length === 0;
            
            const updates = {
                [`players/${playerUUID}/chips`]: playerChips[playerUUID]
            };
            
            const stateUpdates = {
                pot: currentPot,
                [`completedBetting/${playerUUID}`]: true,
                [`playerBets/${playerUUID}`]: betAmount
            };
            
            // If this is the first bet, set standard bet and store the bettor
            if (isFirstBet) {
                stateUpdates.currentBet = betAmount;
                stateUpdates.bettingStarter = playerUUID;
                firstPlayerBet = betAmount;
                bettingStarted = true;
                bettingStarter = playerUUID;
            }
            
            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, stateUpdates, lobbyId);
            
            // Update local state immediately to reflect bet
            if (!currentMatchState.completedBetting) currentMatchState.completedBetting = {};
            if (!currentMatchState.playerBets) currentMatchState.playerBets = {};
            currentMatchState.completedBetting[playerUUID] = true;
            currentMatchState.playerBets[playerUUID] = betAmount;
            currentMatchState.pot = currentPot;
            
            disableBettingControls();
            showToast(`Bet placed: ${betAmount} chips!`);
            
            checkBettingPhaseComplete();
        }

        async function goAllIn() {
            const myChips = playerChips[playerUUID] || STARTING_CHIPS;
            
            if (myChips <= 0) {
                showToast('No chips to go all in!');
                return;
            }
            
            const allInAmount = myChips;
            currentPot += allInAmount;
            playerChips[playerUUID] = 0;
            
            const isFirstBet = !currentMatchState.playerBets || Object.keys(currentMatchState.playerBets || {}).length === 0;
            
            const updates = {
                [`players/${playerUUID}/chips`]: 0
            };
            
            const stateUpdates = {
                pot: currentPot,
                [`completedBetting/${playerUUID}`]: true,
                [`playerBets/${playerUUID}`]: allInAmount
            };
            
            if (isFirstBet) {
                stateUpdates.currentBet = allInAmount;
                stateUpdates.bettingStarter = playerUUID;
                firstPlayerBet = allInAmount;
                bettingStarted = true;
                bettingStarter = playerUUID;
            }
            
            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, stateUpdates, lobbyId);
            
            // Update local state immediately to reflect all-in
            if (!currentMatchState.completedBetting) currentMatchState.completedBetting = {};
            if (!currentMatchState.playerBets) currentMatchState.playerBets = {};
            currentMatchState.completedBetting[playerUUID] = true;
            currentMatchState.playerBets[playerUUID] = allInAmount;
            currentMatchState.pot = currentPot;
            
            disableBettingControls();
            showToast(`All in with ${allInAmount} chips!`);
            
            checkBettingPhaseComplete();
        }

        async function fold() {
            hasFolded = true;
            
            await updateGameSpecificState(GAME_TYPE, {
                [`folded/${playerUUID}`]: true,
                [`completedBetting/${playerUUID}`]: true,
                [`completedRolling/${playerUUID}`]: true
            }, lobbyId);
            
            // Update local state immediately to reflect fold
            if (!currentMatchState.folded) currentMatchState.folded = {};
            if (!currentMatchState.completedBetting) currentMatchState.completedBetting = {};
            if (!currentMatchState.completedRolling) currentMatchState.completedRolling = {};
            currentMatchState.folded[playerUUID] = true;
            currentMatchState.completedBetting[playerUUID] = true;
            currentMatchState.completedRolling[playerUUID] = true;
            
            disableBettingControls();
            disableControls();
            showToast('You folded!');
            
            checkBettingPhaseComplete();
        }

        async function checkBettingPhaseComplete() {
            if (!isHostClient()) return;
            if (isBettingCheckInProgress) return;
            
            isBettingCheckInProgress = true;
            
            try {
                const snapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
                const state = snapshot.val();
                
                if (!state) {
                    console.log('No match state found');
                    return;
                }
                
                const turnOrder = state.turnOrder || [];
                const completedBetting = state.completedBetting || {};
                const folded = state.folded || {};
                
                // Check if all players have completed betting
                const allDone = turnOrder.every(pid => completedBetting[pid]);
                
                console.log('Checking betting phase: allDone=', allDone, 'completedBetting=', completedBetting);
                
                if (allDone) {
                    // Move to rolling phase
                    const activePlayers = turnOrder.filter(pid => !folded[pid]);
                    
                    console.log('Betting complete! Active players:', activePlayers);
                    
                    if (activePlayers.length === 1) {
                        // Only one player left, they win
                        await handleSingleWinner(activePlayers[0]);
                    } else {
                        // Start rolling phase with the player who bet first
                        const startPlayer = state.bettingStarter || activePlayers[0];
                        console.log('Starting playing phase with player:', startPlayer);
                        
                        // Update local state immediately
                        currentMatchState.status = 'playing';
                        currentMatchState.currentTurn = startPlayer;
                        bettingStarted = false;
                        playerTurnComplete = false; // Reset for new phase
                        
                        // Update UI immediately
                        handleTurnLogic();
                        updateGameStatus();
                        
                        // Persist to Firebase
                        await updateGameSpecificState(GAME_TYPE, {
                            status: 'playing',
                            currentTurn: startPlayer
                        }, lobbyId);
                    }
                } else {
                    // Advance to next player who has not completed betting
                    if (turnOrder.length === 0) return;
                    const currentIndex = turnOrder.indexOf(state.currentTurn);
                    const startIndex = currentIndex >= 0 ? currentIndex : -1;
                    let nextIndex = startIndex;
                    let nextPlayer = null;
                    
                    for (let i = 0; i < turnOrder.length; i++) {
                        nextIndex = (nextIndex + 1) % turnOrder.length;
                        const candidate = turnOrder[nextIndex];
                        if (!completedBetting[candidate]) {
                            nextPlayer = candidate;
                            break;
                        }
                    }
                    
                    if (nextPlayer && nextPlayer !== state.currentTurn) {
                        console.log('Advancing to next bettor:', nextPlayer);
                        
                        // Update local state immediately
                        currentMatchState.currentTurn = nextPlayer;
                        
                        // Update UI immediately
                        handleTurnLogic();
                        updateGameStatus();
                        
                        // Persist to Firebase
                        await updateGameSpecificState(GAME_TYPE, {
                            currentTurn: nextPlayer
                        }, lobbyId);
                    }
                }
            } finally {
                isBettingCheckInProgress = false;
            }
        }

        async function handleSingleWinner(winnerId) {
            // Award pot to winner and increment wins
            const winnerChips = playerChips[winnerId] + currentPot;
            
            await db.ref(`lobbies/${lobbyId}/players/${winnerId}/chips`).set(winnerChips);
            await db.ref(`lobbies/${lobbyId}/players/${winnerId}/score`).set(0);
            await db.ref(`lobbies/${lobbyId}/players/${winnerId}/totalWins`).set(
                (lobbyPlayers[winnerId].totalWins || 0) + 1
            );
            
            const rankings = [{
                playerId: winnerId,
                playerName: lobbyPlayers[winnerId].name,
                score: 0,
                winnings: currentPot,
                netGain: currentPot,
                rank: 1,
                isWinner: true
            }];
            
            await updateGameSpecificState(GAME_TYPE, {
                gameOver: true,
                winner: winnerId,
                rankings: rankings
            });
        }

        // ==============================
        // ROLLING LOGIC
        // ==============================
        function enableRollingControls() {
            // Hide betting section
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'none';
            }
            
            resetTurn();
            document.getElementById('roll-btn').disabled = false;
            document.getElementById('end-turn-btn').disabled = true;
        }

        function disableRollingControls() {
            document.getElementById('roll-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = true;
        }

        function renderDice() {
            const container = document.getElementById('dice-container');
            container.innerHTML = '';

            dice.forEach((value, index) => {
                const dieEl = document.createElement('div');
                const isDisabled = rollsLeft === 3 && value === 0;
                dieEl.className = `die ${heldDice[index] ? 'held' : ''} ${isDisabled ? 'disabled' : ''}`;
                dieEl.textContent = value || '?';
                dieEl.onclick = () => toggleHold(index);
                container.appendChild(dieEl);
            });
        }

        function toggleHold(index) {
            if (rollsLeft === 2 || dice[index] === 0) return;
            if (currentMatchState.currentTurn !== playerUUID || hasFolded) return;
            
            heldDice[index] = !heldDice[index];
            renderDice();
        }

        async function rollDice() {
            if (rollsLeft === 0) return;
            if (currentMatchState.currentTurn !== playerUUID || hasFolded) return;

            rollsLeft--;
            document.getElementById('rolls-left').textContent = rollsLeft;

            dice = dice.map((val, i) => heldDice[i] ? val : Math.floor(Math.random() * 6) + 1);
            
            renderDice();
            evaluateHand();

            if (rollsLeft === 0) {
                document.getElementById('roll-btn').disabled = true;
                document.getElementById('end-turn-btn').disabled = false;
            }
        }

        function evaluateHand() {
            // Count occurrences of each die value
            const counts = {};
            dice.forEach(d => {
                counts[d] = (counts[d] || 0) + 1;
            });
            
            const values = Object.values(counts).sort((a, b) => b - a);
            const uniqueValues = Object.keys(counts).map(Number).sort((a, b) => a - b);
            
            let handName = '';
            let rank = 0;
            
            // Check for hands (highest to lowest)
            if (values[0] === 5) {
                handName = 'üåü FIVE OF A KIND!';
                rank = 7;
            } else if (values[0] === 4) {
                handName = 'üíé FOUR OF A KIND!';
                rank = 6;
            } else if (values[0] === 3 && values[1] === 2) {
                handName = 'üè† FULL HOUSE!';
                rank = 5;
            } else if (uniqueValues.length === 5 && 
                       (uniqueValues.join('') === '12345' || uniqueValues.join('') === '23456')) {
                handName = 'üìä STRAIGHT!';
                rank = 4;
            } else if (values[0] === 3) {
                handName = 'üéØ THREE OF A KIND';
                rank = 3;
            } else if (values[0] === 2 && values[1] === 2) {
                handName = 'üë• TWO PAIR';
                rank = 2;
            } else if (values[0] === 2) {
                handName = 'üé≤ ONE PAIR';
                rank = 1;
            } else {
                handName = 'High Card';
                rank = 0;
            }
            
            currentScore = rank;
            document.getElementById('current-score').textContent = rank;
            document.getElementById('hand-result').textContent = handName;
        }

        // ==============================
        // TURN MANAGEMENT
        // ==============================
        async function endTurn() {
            if (currentMatchState.currentTurn !== playerUUID || hasFolded) return;

            await db.ref(`lobbies/${lobbyId}/players/${playerUUID}/score`).set(currentScore);
            await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}/completedRolling/${playerUUID}`).set(true);
            
            // Mark this turn as complete locally to prevent re-enabling controls before turn advances
            playerTurnComplete = true;
            
            disableControls();
            showToast('Turn ended!');
            
            checkRollingPhaseComplete();
        }

        async function checkRollingPhaseComplete() {
            if (!isHostClient()) return;
            if (isRollingCheckInProgress) return;
            
            isRollingCheckInProgress = true;
            
            try {
                const snapshot = await db.ref(`lobbies/${lobbyId}/gameStates/${GAME_TYPE}`).once('value');
                const state = snapshot.val();
                
                const turnOrder = state.turnOrder || [];
                const completedRolling = state.completedRolling || {};
                const folded = state.folded || {};
                
                const activePlayers = turnOrder.filter(pid => !folded[pid]);
                const allDone = activePlayers.every(pid => completedRolling[pid]);
                
                console.log('Checking rolling phase: allDone=', allDone, 'turnOrder=', turnOrder.map(p => lobbyPlayers[p]?.name), 'completedRolling=', Object.keys(completedRolling).map(k => lobbyPlayers[k]?.name));
                
                if (allDone) {
                    console.log('All players rolled! Finishing game...');
                    finishGame();
                } else {
                    // Move to next active player
                    const currentIndex = turnOrder.indexOf(state.currentTurn);
                    console.log('Current player index:', currentIndex, 'current player:', lobbyPlayers[state.currentTurn]?.name);
                    let nextIndex = (currentIndex + 1) % turnOrder.length;
                    
                    while (folded[turnOrder[nextIndex]]) {
                        nextIndex = (nextIndex + 1) % turnOrder.length;
                    }
                    
                    console.log('Advancing to next roller index:', nextIndex, 'player:', lobbyPlayers[turnOrder[nextIndex]]?.name);
                    await updateGameSpecificState(GAME_TYPE, {
                        currentTurn: turnOrder[nextIndex]
                    }, lobbyId);
                    console.log('Firebase updated with new currentTurn');
                }
            } finally {
                isRollingCheckInProgress = false;
            }
        }

        function resetTurn() {
            rollsLeft = 2;
            dice = [0, 0, 0, 0, 0];
            heldDice = [false, false, false, false, false];
            currentScore = 0;
            
            document.getElementById('rolls-left').textContent = rollsLeft;
            document.getElementById('current-score').textContent = currentScore;
            document.getElementById('hand-result').textContent = 'Roll to see your hand!';
            
            renderDice();
        }

        function enableControls() {
            document.getElementById('roll-btn').disabled = false;
            document.getElementById('end-turn-btn').disabled = true;
        }

        function disableControls() {
            // Hide betting section
            const bettingSection = document.getElementById('betting-section');
            if (bettingSection) {
                bettingSection.style.display = 'none';
            }
            
            document.getElementById('roll-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = true;
        }



        function isHostClient() {
            // First real (non-bot) player is the host
            const realPlayers = Object.entries(lobbyPlayers)
                .filter(([id, player]) => !player.isBot)
                .sort((a, b) => (a[1].joinedAt || 0) - (b[1].joinedAt || 0));
            
            return realPlayers.length > 0 && realPlayers[0][0] === playerUUID;
        }

        function getHandName(score) {
            const handNames = {
                7: 'Five of a Kind',
                6: 'Four of a Kind',
                5: 'Full House',
                4: 'Straight',
                3: 'Three of a Kind',
                2: 'Two Pair',
                1: 'One Pair',
                0: 'High Card'
            };
            return handNames[score] || null;
        }

        async function updateMatchState(updates) {
            if (!lobbyId || !db) return;
            await updateGameSpecificState(GAME_TYPE, updates, lobbyId);
        }

        // ==============================
        // BOT LOGIC
        // ==============================
        async function runBotBet(botId) {
            const botChips = playerChips[botId] || STARTING_CHIPS;
            const betAmount = Math.min(firstPlayerBet, botChips);
            
            // Bots always call (no fold)
            if (betAmount <= 0) {
                // Bot has no chips
                await updateGameSpecificState(GAME_TYPE, {
                    [`folded/${botId}`]: true,
                    [`completedBetting/${botId}`]: true,
                    [`completedRolling/${botId}`]: true
                }, lobbyId);
                showToast(`${lobbyPlayers[botId].name} has no chips!`);
            } else if (botChips < firstPlayerBet) {
                // Bot goes all-in if short on chips
                playerChips[botId] = 0;
                currentPot += botChips;
                
                await db.ref(`lobbies/${lobbyId}/players/${botId}/chips`).set(0);
                await updateGameSpecificState(GAME_TYPE, {
                    pot: currentPot,
                    [`completedBetting/${botId}`]: true,
                    [`playerBets/${botId}`]: botChips
                }, lobbyId);
                
                showToast(`${lobbyPlayers[botId].name} went all-in with ${botChips} chips!`);
            } else {
                // Bot calls the bet
                playerChips[botId] = botChips - betAmount;
                currentPot += betAmount;
                
                await db.ref(`lobbies/${lobbyId}/players/${botId}/chips`).set(playerChips[botId]);
                await updateGameSpecificState(GAME_TYPE, {
                    pot: currentPot,
                    [`completedBetting/${botId}`]: true,
                    [`playerBets/${botId}`]: betAmount
                }, lobbyId);
                
                showToast(`${lobbyPlayers[botId].name} called with ${betAmount} chips!`);
            }
            
            checkBettingPhaseComplete();
        }

        async function runBotRoll(botId) {
            let botDice = [0, 0, 0, 0, 0];
            let botHeld = [false, false, false, false, false];
            
            for (let roll = 0; roll < 2; roll++) {
                botDice = botDice.map((val, i) => botHeld[i] ? val : Math.floor(Math.random() * 6) + 1);
                
                if (roll === 0) {
                    const counts = {};
                    botDice.forEach(d => counts[d] = (counts[d] || 0) + 1);
                    
                    botDice.forEach((val, i) => {
                        if (counts[val] >= 2) {
                            botHeld[i] = true;
                        }
                    });
                }
            }
            
            const botScore = calculateBotScore(botDice);
            
            await db.ref(`lobbies/${lobbyId}/players/${botId}/score`).set(botScore);
            await updateGameSpecificState(GAME_TYPE, {
                [`completedRolling/${botId}`]: true
            }, lobbyId);
            
            showToast(`${lobbyPlayers[botId].name} rolled! Score: ${botScore}`);
            
            checkRollingPhaseComplete();
        }

        function calculateBotScore(dice) {
            const counts = {};
            dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            
            const values = Object.values(counts).sort((a, b) => b - a);
            const uniqueValues = Object.keys(counts).map(Number).sort((a, b) => a - b);
            
            if (values[0] === 5) return 7;
            if (values[0] === 4) return 6;
            if (values[0] === 3 && values[1] === 2) return 5;
            if (uniqueValues.length === 5 && 
                (uniqueValues.join('') === '12345' || uniqueValues.join('') === '23456')) return 4;
            if (values[0] === 3) return 3;
            if (values[0] === 2 && values[1] === 2) return 2;
            if (values[0] === 2) return 1;
            return 0;
        }

        // ==============================
        // GAME END & SCOREBOARD
        // ==============================
        async function finishGame() {
            const folded = currentMatchState.folded || {};
            const playerScores = {};
            let highestScore = -1;
            
            // Get hand names for display
            const handNames = {
                7: 'Five of a Kind',
                6: 'Four of a Kind',
                5: 'Full House',
                4: 'Straight',
                3: 'Three of a Kind',
                2: 'Two Pair',
                1: 'One Pair',
                0: 'High Card',
                '-1': 'FOLDED'
            };
            
            Object.entries(lobbyPlayers).forEach(([playerId, player]) => {
                const score = folded[playerId] ? -1 : (player.score || 0);
                playerScores[playerId] = score;
                
                if (score > highestScore) {
                    highestScore = score;
                }
            });
            
            // Find all winners (could be multiple in case of tie)
            const winnerIds = Object.entries(playerScores)
                .filter(([_, score]) => score === highestScore && score >= 0)
                .map(([playerId, _]) => playerId);
            
            console.log('Winners:', winnerIds, 'Score:', highestScore);
            
            // Split pot evenly among winners
            const potPerWinner = Math.floor(currentPot / winnerIds.length);
            const potRemainder = currentPot % winnerIds.length;
            
            const updates = {};
            
            // Award pot to winners and increment wins
            winnerIds.forEach((winnerId, index) => {
                const chipGain = potPerWinner + (index === 0 ? potRemainder : 0);
                const winnerChips = playerChips[winnerId] + chipGain;
                updates[`players/${winnerId}/chips`] = winnerChips;
                updates[`players/${winnerId}/totalWins`] = (lobbyPlayers[winnerId].totalWins || 0) + 1;
                playerChips[winnerId] = winnerChips;
            });
            
            // Calculate net gain/loss for each player
            const rankings = Object.entries(playerScores)
                .sort((a, b) => {
                    if (a[1] === b[1]) return 0;
                    if (a[1] === -1) return 1;
                    if (b[1] === -1) return -1;
                    return b[1] - a[1];
                })
                .map(([playerId, score], index) => {
                    const betAmount = (currentMatchState.playerBets && currentMatchState.playerBets[playerId]) || 0;
                    const finalChips = playerChips[playerId];
                    const netGain = finalChips - STARTING_CHIPS;
                    const handName = handNames[score] || 'Unknown';
                    const isWinner = winnerIds.includes(playerId);
                    
                    return {
                        playerId,
                        playerName: lobbyPlayers[playerId].name,
                        hand: handName,
                        score: score === -1 ? 'FOLDED' : score,
                        winnings: isWinner ? Math.floor(currentPot / winnerIds.length) + (winnerIds.indexOf(playerId) === 0 ? currentPot % winnerIds.length : 0) : 0,
                        betAmount: betAmount,
                        netGain: netGain,
                        rank: index + 1,
                        isWinner: isWinner
                    };
                });
            
            // Update chip counts in Firebase
            const chipUpdates = {};
            Object.entries(playerChips).forEach(([pid, chips]) => {
                chipUpdates[`players/${pid}/chips`] = chips;
                chipUpdates[`players/${pid}/totalWins`] = lobbyPlayers[pid].totalWins || 0;
            });
            
            winnerIds.forEach(wid => {
                chipUpdates[`players/${wid}/totalWins`] = (lobbyPlayers[wid].totalWins || 0) + 1;
            });
            
            await db.ref(`lobbies/${lobbyId}`).update(chipUpdates);
            
            // Update game state
            await updateGameSpecificState(GAME_TYPE, {
                gameOver: true,
                winners: winnerIds,
                rankings: rankings,
                status: 'finished'
            }, lobbyId);
            
            showScoreboard(rankings, winnerIds[0]);
        }

        function showScoreboard(rankings, winnerPlayerId) {
            populateScoreboard(rankings, winnerPlayerId);
            document.getElementById('scoreboardModal').classList.add('active');
            scoreboardShown = true;
        }

        function populateScoreboard(rankings, winnerPlayerId) {
            const resultsContainer = document.getElementById('scoreboardResults');
            resultsContainer.innerHTML = '';
            
            rankings.forEach((entry) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'score-row-item';
                
                const rankDisplay = ['ü•á', 'ü•à', 'ü•â'][entry.rank - 1] || `#${entry.rank}`;
                const winnerBadge = entry.isWinner ? '<span class="winner-badge">üëë WINNER</span>' : '';
                
                // Show net gain/loss with color
                const netGainColor = entry.netGain >= 0 ? '#27ae60' : '#e74c3c';
                const netGainSign = entry.netGain >= 0 ? '+' : '';
                const netGainDisplay = `<div style="color: ${netGainColor}; font-size: 0.9rem; font-weight: bold;">Net: ${netGainSign}${entry.netGain} chips</div>`;
                
                const handDisplay = entry.score === 'FOLDED' ? `<div style="color: #999; font-style: italic;">Folded</div>` : `<div style="color: #ffd700;">Hand: ${entry.hand}</div>`;
                
                resultItem.innerHTML = `
                    <div style="display: flex; align-items: center; width: 100%; gap: 15px;">
                        <div style="font-size: 1.8rem; min-width: 50px;">${rankDisplay}</div>
                        <div style="flex: 1;">
                            <div style="font-size: 1.2rem; font-weight: bold;">${entry.playerName}</div>
                            ${handDisplay}
                            ${netGainDisplay}
                        </div>
                        ${winnerBadge}
                    </div>
                `;
                
                if (entry.isWinner) {
                    resultItem.classList.add('winner');
                }
                
                resultsContainer.appendChild(resultItem);
            });
        }

        async function returnToLobbyFromScoreboard() {
            document.getElementById('scoreboardModal').classList.remove('active');
            
            // Stop listening but keep player in lobby
            if (window.globalLobbyRef) {
                offLobbyUpdate(window.globalLobbyRef);
                window.globalLobbyRef = null;
            }
            
            // Mark player as back in lobby
            await updatePlayerStatus('inLobby', lobbyId);
            
            // Preserve lobby ID
            if (lobbyId) {
                window.currentLobbyId = lobbyId;
                sessionStorage.setItem('currentLobbyId', lobbyId);
            }
            
            // Redirect to lobby
            window.location.href = '../../lobby.html';
        }

        async function playAgain() {
            document.getElementById('scoreboardModal').classList.remove('active');
            
            dice = [0, 0, 0, 0, 0];
            heldDice = [false, false, false, false, false];
            rollsLeft = 2;
            currentScore = 0;
            currentPot = 0;
            scoreboardShown = false;
            gameStarted = false;
            hasFolded = false;
            gameInitialized = false; // Reset so ready-up shows again
            
            renderDice();
            
            // Reset all players - prepare for new round
            const turnPlayers = Object.keys(lobbyPlayers);
            const updates = {};
            
            // Reset player scores
            turnPlayers.forEach(playerId => {
                updates[`players/${playerId}/score`] = 0;
            });
            
            // Reset match state to waiting (ready-up again)
            const playerStates = {};
            turnPlayers.forEach(playerId => {
                playerStates[playerId] = {
                    ready: lobbyPlayers[playerId].isBot ? true : false,
                    score: 0
                };
            });
            
            const nextMatchState = {
                status: 'waiting',
                turnOrder: turnPlayers,
                currentTurn: turnPlayers[0],
                round: (currentMatchState.round || 1) + 1,
                pot: 0,
                currentBet: 0,
                playerBets: {},
                folded: {},
                completedBetting: {},
                completedRolling: {},
                playerStates: playerStates,
                gameOver: false,
                winner: null,
                rankings: null
            };
            
            await db.ref(`lobbies/${lobbyId}`).update(updates);
            await updateGameSpecificState(GAME_TYPE, nextMatchState, lobbyId);
            
            showToast('New game started! Ready up to begin...');
        }

        // ==============================
        // UTILITY FUNCTIONS
        // ==============================
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        async function returnToLobby() {
            if (confirm('Are you sure you want to leave the game?')) {
                try {
                    // Stop listening to lobby updates
                    if (window.globalLobbyRef) {
                        offLobbyUpdate(window.globalLobbyRef);
                        window.globalLobbyRef = null;
                    }
                    
                    // Mark player as back in lobby
                    await updatePlayerStatus('inLobby', lobbyId);
                    
                    // Keep player in lobby and preserve current lobby ID
                    if (lobbyId) {
                        window.currentLobbyId = lobbyId;
                        sessionStorage.setItem('currentLobbyId', lobbyId);
                    }
                } catch (error) {
                    console.error('Error leaving lobby:', error);
                }
                // Allow a moment for cleanup before redirecting
                setTimeout(() => {
                    window.location.href = '../../lobby.html';
                }, 300);
            }
        }

        async function leaveLobby() {
            if (!db || !lobbyId || !playerUUID) {
                console.error('Missing required data for leaving lobby');
                return false;
            }
            
            try {
                // Remove player from lobby
                await db.ref(`lobbies/${lobbyId}/players/${playerUUID}`).remove();
                console.log('Left lobby:', lobbyId);
                window.currentLobbyId = null;
                sessionStorage.removeItem('currentLobbyId');
                return true;
            } catch (error) {
                console.error('Error leaving lobby:', error);
                return false;
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (window.globalLobbyRef) {
                offLobbyUpdate(window.globalLobbyRef);
            }
        });
    </script>
</body>
</html>
